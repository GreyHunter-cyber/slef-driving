// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "robot.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* RobotDrive_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotDrive_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RobotDrive_Mode_descriptor_ = NULL;
const ::google::protobuf::Descriptor* MitionPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MitionPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* OriginPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OriginPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapList_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotRequest_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RobotRequest_Wants_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RobotRequest_Action_descriptor_ = NULL;
const ::google::protobuf::Descriptor* RobotMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotMap_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RobotMap_Grid_descriptor_ = NULL;
const ::google::protobuf::Descriptor* RobotPos_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotPos_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotTrail_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotTrail_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* MitionStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MitionStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* RobotResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RobotResponse_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_robot_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_robot_2eproto() {
  protobuf_AddDesc_robot_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "robot.proto");
  GOOGLE_CHECK(file != NULL);
  RobotDrive_descriptor_ = file->message_type(0);
  static const int RobotDrive_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotDrive, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotDrive, speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotDrive, angle_),
  };
  RobotDrive_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RobotDrive_descriptor_,
      RobotDrive::default_instance_,
      RobotDrive_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotDrive, _has_bits_[0]),
      -1,
      -1,
      sizeof(RobotDrive),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotDrive, _internal_metadata_),
      -1);
  RobotDrive_Mode_descriptor_ = RobotDrive_descriptor_->enum_type(0);
  MitionPoint_descriptor_ = file->message_type(1);
  static const int MitionPoint_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MitionPoint, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MitionPoint, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MitionPoint, attribute_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MitionPoint, m_speed_),
  };
  MitionPoint_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MitionPoint_descriptor_,
      MitionPoint::default_instance_,
      MitionPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MitionPoint, _has_bits_[0]),
      -1,
      -1,
      sizeof(MitionPoint),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MitionPoint, _internal_metadata_),
      -1);
  OriginPoint_descriptor_ = file->message_type(2);
  static const int OriginPoint_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginPoint, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginPoint, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginPoint, z_),
  };
  OriginPoint_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      OriginPoint_descriptor_,
      OriginPoint::default_instance_,
      OriginPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginPoint, _has_bits_[0]),
      -1,
      -1,
      sizeof(OriginPoint),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OriginPoint, _internal_metadata_),
      -1);
  MapList_descriptor_ = file->message_type(3);
  static const int MapList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapList, mapname_),
  };
  MapList_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MapList_descriptor_,
      MapList::default_instance_,
      MapList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapList, _has_bits_[0]),
      -1,
      -1,
      sizeof(MapList),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapList, _internal_metadata_),
      -1);
  RobotRequest_descriptor_ = file->message_type(4);
  static const int RobotRequest_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotRequest, token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotRequest, wants_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotRequest, action_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotRequest, drive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotRequest, point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotRequest, origin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotRequest, confirm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotRequest, mapname_),
  };
  RobotRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RobotRequest_descriptor_,
      RobotRequest::default_instance_,
      RobotRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotRequest, _has_bits_[0]),
      -1,
      -1,
      sizeof(RobotRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotRequest, _internal_metadata_),
      -1);
  RobotRequest_Wants_descriptor_ = RobotRequest_descriptor_->enum_type(0);
  RobotRequest_Action_descriptor_ = RobotRequest_descriptor_->enum_type(1);
  RobotMap_descriptor_ = file->message_type(5);
  static const int RobotMap_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMap, origin_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMap, origin_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMap, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMap, grids_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMap, grids_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMap, zgrids_),
  };
  RobotMap_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RobotMap_descriptor_,
      RobotMap::default_instance_,
      RobotMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMap, _has_bits_[0]),
      -1,
      -1,
      sizeof(RobotMap),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotMap, _internal_metadata_),
      -1);
  RobotMap_Grid_descriptor_ = RobotMap_descriptor_->enum_type(0);
  RobotPos_descriptor_ = file->message_type(6);
  static const int RobotPos_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPos, offset_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPos, offset_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPos, angle_),
  };
  RobotPos_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RobotPos_descriptor_,
      RobotPos::default_instance_,
      RobotPos_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPos, _has_bits_[0]),
      -1,
      -1,
      sizeof(RobotPos),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotPos, _internal_metadata_),
      -1);
  RobotTrail_descriptor_ = file->message_type(7);
  static const int RobotTrail_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotTrail, trail_),
  };
  RobotTrail_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RobotTrail_descriptor_,
      RobotTrail::default_instance_,
      RobotTrail_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotTrail, _has_bits_[0]),
      -1,
      -1,
      sizeof(RobotTrail),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotTrail, _internal_metadata_),
      -1);
  RobotInfo_descriptor_ = file->message_type(8);
  static const int RobotInfo_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, voltage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, cur_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, cur_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, cur_yaw_),
  };
  RobotInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RobotInfo_descriptor_,
      RobotInfo::default_instance_,
      RobotInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(RobotInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotInfo, _internal_metadata_),
      -1);
  MitionStatus_descriptor_ = file->message_type(9);
  static const int MitionStatus_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MitionStatus, mition_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MitionStatus, mition_finish_),
  };
  MitionStatus_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MitionStatus_descriptor_,
      MitionStatus::default_instance_,
      MitionStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MitionStatus, _has_bits_[0]),
      -1,
      -1,
      sizeof(MitionStatus),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MitionStatus, _internal_metadata_),
      -1);
  RobotResponse_descriptor_ = file->message_type(10);
  static const int RobotResponse_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, map_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, trail_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, point_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, mition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, list_),
  };
  RobotResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RobotResponse_descriptor_,
      RobotResponse::default_instance_,
      RobotResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, _has_bits_[0]),
      -1,
      -1,
      sizeof(RobotResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RobotResponse, _internal_metadata_),
      -1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_robot_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RobotDrive_descriptor_, &RobotDrive::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MitionPoint_descriptor_, &MitionPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      OriginPoint_descriptor_, &OriginPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MapList_descriptor_, &MapList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RobotRequest_descriptor_, &RobotRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RobotMap_descriptor_, &RobotMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RobotPos_descriptor_, &RobotPos::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RobotTrail_descriptor_, &RobotTrail::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RobotInfo_descriptor_, &RobotInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MitionStatus_descriptor_, &MitionStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RobotResponse_descriptor_, &RobotResponse::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_robot_2eproto() {
  delete RobotDrive::default_instance_;
  delete RobotDrive_reflection_;
  delete MitionPoint::default_instance_;
  delete MitionPoint_reflection_;
  delete OriginPoint::default_instance_;
  delete OriginPoint_reflection_;
  delete MapList::default_instance_;
  delete MapList_reflection_;
  delete RobotRequest::default_instance_;
  delete RobotRequest_reflection_;
  delete RobotMap::default_instance_;
  delete RobotMap_reflection_;
  delete RobotPos::default_instance_;
  delete RobotPos_reflection_;
  delete RobotTrail::default_instance_;
  delete RobotTrail_reflection_;
  delete RobotInfo::default_instance_;
  delete RobotInfo_reflection_;
  delete MitionStatus::default_instance_;
  delete MitionStatus_reflection_;
  delete RobotResponse::default_instance_;
  delete RobotResponse_reflection_;
}

void protobuf_AddDesc_robot_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_robot_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013robot.proto\"|\n\nRobotDrive\022\036\n\004mode\030\001 \002("
    "\0162\020.RobotDrive.Mode\022\r\n\005speed\030\002 \001(\002\022\r\n\005an"
    "gle\030\003 \001(\002\"0\n\004Mode\022\010\n\004FREE\020\000\022\t\n\005PAUSE\020\001\022\010"
    "\n\004STOP\020\002\022\t\n\005DRIVE\020\003\"G\n\013MitionPoint\022\t\n\001x\030"
    "\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\021\n\tattribute\030\003 \002(\005\022\017\n\007m"
    "_speed\030\004 \002(\002\".\n\013OriginPoint\022\t\n\001x\030\001 \002(\002\022\t"
    "\n\001y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\"\032\n\007MapList\022\017\n\007mapna"
    "me\030\001 \003(\t\"\375\002\n\014RobotRequest\022\r\n\005token\030\001 \002(\014"
    "\022\r\n\005wants\030\002 \002(\005\022\016\n\006action\030\003 \002(\005\022\032\n\005drive"
    "\030\004 \001(\0132\013.RobotDrive\022\033\n\005point\030\005 \003(\0132\014.Mit"
    "ionPoint\022\034\n\006origin\030\006 \001(\0132\014.OriginPoint\022\017"
    "\n\007confirm\030\007 \001(\005\022\017\n\007mapname\030\010 \001(\t\".\n\005Want"
    "s\022\010\n\004NONE\020\000\022\007\n\003POS\020\001\022\007\n\003MAP\020\002\022\t\n\005TRAIL\020\004"
    "\"\225\001\n\006Action\022\010\n\004NOOP\020\000\022\017\n\013POINT_APPLY\020\001\022\016"
    "\n\nNAVIGATION\020\002\022\017\n\013INIT_ORIGIN\020\003\022\r\n\tCREAT"
    "_MAP\020\004\022\016\n\nFINISH_MAP\020\005\022\016\n\nUPLOAD_MAP\020\006\022\020"
    "\n\014DOWNLOAD_MAP\020\007\022\016\n\nCHOICE_MAP\020\010\"\247\001\n\010Rob"
    "otMap\022\020\n\010origin_x\030\001 \002(\001\022\020\n\010origin_y\030\002 \002("
    "\001\022\014\n\004size\030\003 \002(\005\022\017\n\007grids_x\030\004 \002(\005\022\017\n\007grid"
    "s_y\030\005 \002(\005\022\016\n\006zgrids\030\006 \002(\014\"7\n\004Grid\022\n\n\006UNK"
    "OWN\020\000\022\010\n\004FREE\020\001\022\014\n\010OCCUPIED\020\002\022\013\n\007FEATURE"
    "\020\003\"=\n\010RobotPos\022\020\n\010offset_x\030\001 \002(\002\022\020\n\010offs"
    "et_y\030\002 \002(\002\022\r\n\005angle\030\003 \001(\002\"&\n\nRobotTrail\022"
    "\030\n\005trail\030\001 \003(\0132\t.RobotPos\"Z\n\tRobotInfo\022\r"
    "\n\005speed\030\001 \002(\002\022\017\n\007voltage\030\002 \002(\002\022\r\n\005cur_x\030"
    "\003 \002(\002\022\r\n\005cur_y\030\004 \002(\002\022\017\n\007cur_yaw\030\005 \002(\002\"<\n"
    "\014MitionStatus\022\025\n\rmition_number\030\001 \002(\005\022\025\n\r"
    "mition_finish\030\002 \002(\010\"\347\001\n\rRobotResponse\022\014\n"
    "\004code\030\001 \002(\005\022\014\n\004info\030\002 \001(\t\022\026\n\003pos\030\003 \001(\0132\t"
    ".RobotPos\022\026\n\003map\030\004 \001(\0132\t.RobotMap\022\032\n\005tra"
    "il\030\005 \001(\0132\013.RobotTrail\022\033\n\005point\030\006 \001(\0132\014.M"
    "itionPoint\022\032\n\006status\030\007 \001(\0132\n.RobotInfo\022\035"
    "\n\006mition\030\010 \001(\0132\r.MitionStatus\022\026\n\004list\030\t "
    "\001(\0132\010.MapList", 1333);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "robot.proto", &protobuf_RegisterTypes);
  RobotDrive::default_instance_ = new RobotDrive();
  MitionPoint::default_instance_ = new MitionPoint();
  OriginPoint::default_instance_ = new OriginPoint();
  MapList::default_instance_ = new MapList();
  RobotRequest::default_instance_ = new RobotRequest();
  RobotMap::default_instance_ = new RobotMap();
  RobotPos::default_instance_ = new RobotPos();
  RobotTrail::default_instance_ = new RobotTrail();
  RobotInfo::default_instance_ = new RobotInfo();
  MitionStatus::default_instance_ = new MitionStatus();
  RobotResponse::default_instance_ = new RobotResponse();
  RobotDrive::default_instance_->InitAsDefaultInstance();
  MitionPoint::default_instance_->InitAsDefaultInstance();
  OriginPoint::default_instance_->InitAsDefaultInstance();
  MapList::default_instance_->InitAsDefaultInstance();
  RobotRequest::default_instance_->InitAsDefaultInstance();
  RobotMap::default_instance_->InitAsDefaultInstance();
  RobotPos::default_instance_->InitAsDefaultInstance();
  RobotTrail::default_instance_->InitAsDefaultInstance();
  RobotInfo::default_instance_->InitAsDefaultInstance();
  MitionStatus::default_instance_->InitAsDefaultInstance();
  RobotResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_robot_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_robot_2eproto {
  StaticDescriptorInitializer_robot_2eproto() {
    protobuf_AddDesc_robot_2eproto();
  }
} static_descriptor_initializer_robot_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* RobotDrive_Mode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotDrive_Mode_descriptor_;
}
bool RobotDrive_Mode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RobotDrive_Mode RobotDrive::FREE;
const RobotDrive_Mode RobotDrive::PAUSE;
const RobotDrive_Mode RobotDrive::STOP;
const RobotDrive_Mode RobotDrive::DRIVE;
const RobotDrive_Mode RobotDrive::Mode_MIN;
const RobotDrive_Mode RobotDrive::Mode_MAX;
const int RobotDrive::Mode_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RobotDrive::kModeFieldNumber;
const int RobotDrive::kSpeedFieldNumber;
const int RobotDrive::kAngleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RobotDrive::RobotDrive()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RobotDrive)
}

void RobotDrive::InitAsDefaultInstance() {
}

RobotDrive::RobotDrive(const RobotDrive& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RobotDrive)
}

void RobotDrive::SharedCtor() {
  _cached_size_ = 0;
  mode_ = 0;
  speed_ = 0;
  angle_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotDrive::~RobotDrive() {
  // @@protoc_insertion_point(destructor:RobotDrive)
  SharedDtor();
}

void RobotDrive::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobotDrive::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotDrive::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotDrive_descriptor_;
}

const RobotDrive& RobotDrive::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

RobotDrive* RobotDrive::default_instance_ = NULL;

RobotDrive* RobotDrive::New(::google::protobuf::Arena* arena) const {
  RobotDrive* n = new RobotDrive;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RobotDrive::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotDrive)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RobotDrive, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RobotDrive*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(mode_, angle_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RobotDrive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RobotDrive)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .RobotDrive.Mode mode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::RobotDrive_Mode_IsValid(value)) {
            set_mode(static_cast< ::RobotDrive_Mode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_speed;
        break;
      }

      // optional float speed = 2;
      case 2: {
        if (tag == 21) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_angle;
        break;
      }

      // optional float angle = 3;
      case 3: {
        if (tag == 29) {
         parse_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
          set_has_angle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RobotDrive)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RobotDrive)
  return false;
#undef DO_
}

void RobotDrive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RobotDrive)
  // required .RobotDrive.Mode mode = 1;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->mode(), output);
  }

  // optional float speed = 2;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->speed(), output);
  }

  // optional float angle = 3;
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->angle(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RobotDrive)
}

::google::protobuf::uint8* RobotDrive::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotDrive)
  // required .RobotDrive.Mode mode = 1;
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->mode(), target);
  }

  // optional float speed = 2;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->speed(), target);
  }

  // optional float angle = 3;
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->angle(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotDrive)
  return target;
}

int RobotDrive::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RobotDrive)
  int total_size = 0;

  // required .RobotDrive.Mode mode = 1;
  if (has_mode()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
  }
  if (_has_bits_[1 / 32] & 6u) {
    // optional float speed = 2;
    if (has_speed()) {
      total_size += 1 + 4;
    }

    // optional float angle = 3;
    if (has_angle()) {
      total_size += 1 + 4;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotDrive::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RobotDrive)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RobotDrive* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RobotDrive>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RobotDrive)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RobotDrive)
    MergeFrom(*source);
  }
}

void RobotDrive::MergeFrom(const RobotDrive& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotDrive)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_angle()) {
      set_angle(from.angle());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RobotDrive::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RobotDrive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotDrive::CopyFrom(const RobotDrive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotDrive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotDrive::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void RobotDrive::Swap(RobotDrive* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RobotDrive::InternalSwap(RobotDrive* other) {
  std::swap(mode_, other->mode_);
  std::swap(speed_, other->speed_);
  std::swap(angle_, other->angle_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RobotDrive::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotDrive_descriptor_;
  metadata.reflection = RobotDrive_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RobotDrive

// required .RobotDrive.Mode mode = 1;
bool RobotDrive::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RobotDrive::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
void RobotDrive::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
void RobotDrive::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
 ::RobotDrive_Mode RobotDrive::mode() const {
  // @@protoc_insertion_point(field_get:RobotDrive.mode)
  return static_cast< ::RobotDrive_Mode >(mode_);
}
 void RobotDrive::set_mode(::RobotDrive_Mode value) {
  assert(::RobotDrive_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:RobotDrive.mode)
}

// optional float speed = 2;
bool RobotDrive::has_speed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RobotDrive::set_has_speed() {
  _has_bits_[0] |= 0x00000002u;
}
void RobotDrive::clear_has_speed() {
  _has_bits_[0] &= ~0x00000002u;
}
void RobotDrive::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
 float RobotDrive::speed() const {
  // @@protoc_insertion_point(field_get:RobotDrive.speed)
  return speed_;
}
 void RobotDrive::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:RobotDrive.speed)
}

// optional float angle = 3;
bool RobotDrive::has_angle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RobotDrive::set_has_angle() {
  _has_bits_[0] |= 0x00000004u;
}
void RobotDrive::clear_has_angle() {
  _has_bits_[0] &= ~0x00000004u;
}
void RobotDrive::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
 float RobotDrive::angle() const {
  // @@protoc_insertion_point(field_get:RobotDrive.angle)
  return angle_;
}
 void RobotDrive::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:RobotDrive.angle)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MitionPoint::kXFieldNumber;
const int MitionPoint::kYFieldNumber;
const int MitionPoint::kAttributeFieldNumber;
const int MitionPoint::kMSpeedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MitionPoint::MitionPoint()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MitionPoint)
}

void MitionPoint::InitAsDefaultInstance() {
}

MitionPoint::MitionPoint(const MitionPoint& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MitionPoint)
}

void MitionPoint::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  attribute_ = 0;
  m_speed_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MitionPoint::~MitionPoint() {
  // @@protoc_insertion_point(destructor:MitionPoint)
  SharedDtor();
}

void MitionPoint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MitionPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MitionPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MitionPoint_descriptor_;
}

const MitionPoint& MitionPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

MitionPoint* MitionPoint::default_instance_ = NULL;

MitionPoint* MitionPoint::New(::google::protobuf::Arena* arena) const {
  MitionPoint* n = new MitionPoint;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MitionPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:MitionPoint)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(MitionPoint, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MitionPoint*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, m_speed_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MitionPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MitionPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_attribute;
        break;
      }

      // required int32 attribute = 3;
      case 3: {
        if (tag == 24) {
         parse_attribute:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attribute_)));
          set_has_attribute();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_m_speed;
        break;
      }

      // required float m_speed = 4;
      case 4: {
        if (tag == 37) {
         parse_m_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &m_speed_)));
          set_has_m_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MitionPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MitionPoint)
  return false;
#undef DO_
}

void MitionPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MitionPoint)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required int32 attribute = 3;
  if (has_attribute()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->attribute(), output);
  }

  // required float m_speed = 4;
  if (has_m_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->m_speed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MitionPoint)
}

::google::protobuf::uint8* MitionPoint::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MitionPoint)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required int32 attribute = 3;
  if (has_attribute()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->attribute(), target);
  }

  // required float m_speed = 4;
  if (has_m_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->m_speed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MitionPoint)
  return target;
}

int MitionPoint::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:MitionPoint)
  int total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  if (has_attribute()) {
    // required int32 attribute = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->attribute());
  }

  if (has_m_speed()) {
    // required float m_speed = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
int MitionPoint::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:MitionPoint)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

    // required int32 attribute = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->attribute());

    // required float m_speed = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MitionPoint::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:MitionPoint)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MitionPoint* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MitionPoint>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:MitionPoint)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:MitionPoint)
    MergeFrom(*source);
  }
}

void MitionPoint::MergeFrom(const MitionPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MitionPoint)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_attribute()) {
      set_attribute(from.attribute());
    }
    if (from.has_m_speed()) {
      set_m_speed(from.m_speed());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MitionPoint::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:MitionPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MitionPoint::CopyFrom(const MitionPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MitionPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MitionPoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void MitionPoint::Swap(MitionPoint* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MitionPoint::InternalSwap(MitionPoint* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(attribute_, other->attribute_);
  std::swap(m_speed_, other->m_speed_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MitionPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MitionPoint_descriptor_;
  metadata.reflection = MitionPoint_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MitionPoint

// required float x = 1;
bool MitionPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MitionPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void MitionPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void MitionPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
 float MitionPoint::x() const {
  // @@protoc_insertion_point(field_get:MitionPoint.x)
  return x_;
}
 void MitionPoint::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:MitionPoint.x)
}

// required float y = 2;
bool MitionPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MitionPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void MitionPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void MitionPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
 float MitionPoint::y() const {
  // @@protoc_insertion_point(field_get:MitionPoint.y)
  return y_;
}
 void MitionPoint::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:MitionPoint.y)
}

// required int32 attribute = 3;
bool MitionPoint::has_attribute() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void MitionPoint::set_has_attribute() {
  _has_bits_[0] |= 0x00000004u;
}
void MitionPoint::clear_has_attribute() {
  _has_bits_[0] &= ~0x00000004u;
}
void MitionPoint::clear_attribute() {
  attribute_ = 0;
  clear_has_attribute();
}
 ::google::protobuf::int32 MitionPoint::attribute() const {
  // @@protoc_insertion_point(field_get:MitionPoint.attribute)
  return attribute_;
}
 void MitionPoint::set_attribute(::google::protobuf::int32 value) {
  set_has_attribute();
  attribute_ = value;
  // @@protoc_insertion_point(field_set:MitionPoint.attribute)
}

// required float m_speed = 4;
bool MitionPoint::has_m_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void MitionPoint::set_has_m_speed() {
  _has_bits_[0] |= 0x00000008u;
}
void MitionPoint::clear_has_m_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
void MitionPoint::clear_m_speed() {
  m_speed_ = 0;
  clear_has_m_speed();
}
 float MitionPoint::m_speed() const {
  // @@protoc_insertion_point(field_get:MitionPoint.m_speed)
  return m_speed_;
}
 void MitionPoint::set_m_speed(float value) {
  set_has_m_speed();
  m_speed_ = value;
  // @@protoc_insertion_point(field_set:MitionPoint.m_speed)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OriginPoint::kXFieldNumber;
const int OriginPoint::kYFieldNumber;
const int OriginPoint::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OriginPoint::OriginPoint()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:OriginPoint)
}

void OriginPoint::InitAsDefaultInstance() {
}

OriginPoint::OriginPoint(const OriginPoint& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:OriginPoint)
}

void OriginPoint::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OriginPoint::~OriginPoint() {
  // @@protoc_insertion_point(destructor:OriginPoint)
  SharedDtor();
}

void OriginPoint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OriginPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OriginPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OriginPoint_descriptor_;
}

const OriginPoint& OriginPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

OriginPoint* OriginPoint::default_instance_ = NULL;

OriginPoint* OriginPoint::New(::google::protobuf::Arena* arena) const {
  OriginPoint* n = new OriginPoint;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OriginPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:OriginPoint)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(OriginPoint, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<OriginPoint*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, z_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool OriginPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:OriginPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // required float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_z;
        break;
      }

      // required float z = 3;
      case 3: {
        if (tag == 29) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:OriginPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:OriginPoint)
  return false;
#undef DO_
}

void OriginPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:OriginPoint)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float y = 2;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // required float z = 3;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:OriginPoint)
}

::google::protobuf::uint8* OriginPoint::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:OriginPoint)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float y = 2;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // required float z = 3;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:OriginPoint)
  return target;
}

int OriginPoint::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:OriginPoint)
  int total_size = 0;

  if (has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  if (has_z()) {
    // required float z = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
int OriginPoint::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:OriginPoint)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

    // required float z = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OriginPoint::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:OriginPoint)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const OriginPoint* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const OriginPoint>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:OriginPoint)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:OriginPoint)
    MergeFrom(*source);
  }
}

void OriginPoint::MergeFrom(const OriginPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:OriginPoint)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void OriginPoint::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:OriginPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OriginPoint::CopyFrom(const OriginPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:OriginPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OriginPoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void OriginPoint::Swap(OriginPoint* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OriginPoint::InternalSwap(OriginPoint* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(z_, other->z_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OriginPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OriginPoint_descriptor_;
  metadata.reflection = OriginPoint_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OriginPoint

// required float x = 1;
bool OriginPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void OriginPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
void OriginPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void OriginPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
 float OriginPoint::x() const {
  // @@protoc_insertion_point(field_get:OriginPoint.x)
  return x_;
}
 void OriginPoint::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:OriginPoint.x)
}

// required float y = 2;
bool OriginPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void OriginPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
void OriginPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void OriginPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
 float OriginPoint::y() const {
  // @@protoc_insertion_point(field_get:OriginPoint.y)
  return y_;
}
 void OriginPoint::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:OriginPoint.y)
}

// required float z = 3;
bool OriginPoint::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void OriginPoint::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
void OriginPoint::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
void OriginPoint::clear_z() {
  z_ = 0;
  clear_has_z();
}
 float OriginPoint::z() const {
  // @@protoc_insertion_point(field_get:OriginPoint.z)
  return z_;
}
 void OriginPoint::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:OriginPoint.z)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MapList::kMapnameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MapList::MapList()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MapList)
}

void MapList::InitAsDefaultInstance() {
}

MapList::MapList(const MapList& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MapList)
}

void MapList::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapList::~MapList() {
  // @@protoc_insertion_point(destructor:MapList)
  SharedDtor();
}

void MapList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapList_descriptor_;
}

const MapList& MapList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

MapList* MapList::default_instance_ = NULL;

MapList* MapList::New(::google::protobuf::Arena* arena) const {
  MapList* n = new MapList;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MapList::Clear() {
// @@protoc_insertion_point(message_clear_start:MapList)
  mapname_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MapList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MapList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string mapname = 1;
      case 1: {
        if (tag == 10) {
         parse_mapname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_mapname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mapname(this->mapname_size() - 1).data(),
            this->mapname(this->mapname_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "MapList.mapname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_mapname;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MapList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MapList)
  return false;
#undef DO_
}

void MapList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MapList)
  // repeated string mapname = 1;
  for (int i = 0; i < this->mapname_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mapname(i).data(), this->mapname(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "MapList.mapname");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->mapname(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MapList)
}

::google::protobuf::uint8* MapList::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MapList)
  // repeated string mapname = 1;
  for (int i = 0; i < this->mapname_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mapname(i).data(), this->mapname(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "MapList.mapname");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->mapname(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MapList)
  return target;
}

int MapList::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:MapList)
  int total_size = 0;

  // repeated string mapname = 1;
  total_size += 1 * this->mapname_size();
  for (int i = 0; i < this->mapname_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->mapname(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapList::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:MapList)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MapList* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MapList>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:MapList)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:MapList)
    MergeFrom(*source);
  }
}

void MapList::MergeFrom(const MapList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MapList)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  mapname_.MergeFrom(from.mapname_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MapList::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:MapList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapList::CopyFrom(const MapList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MapList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapList::IsInitialized() const {

  return true;
}

void MapList::Swap(MapList* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MapList::InternalSwap(MapList* other) {
  mapname_.UnsafeArenaSwap(&other->mapname_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MapList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapList_descriptor_;
  metadata.reflection = MapList_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MapList

// repeated string mapname = 1;
int MapList::mapname_size() const {
  return mapname_.size();
}
void MapList::clear_mapname() {
  mapname_.Clear();
}
 const ::std::string& MapList::mapname(int index) const {
  // @@protoc_insertion_point(field_get:MapList.mapname)
  return mapname_.Get(index);
}
 ::std::string* MapList::mutable_mapname(int index) {
  // @@protoc_insertion_point(field_mutable:MapList.mapname)
  return mapname_.Mutable(index);
}
 void MapList::set_mapname(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MapList.mapname)
  mapname_.Mutable(index)->assign(value);
}
 void MapList::set_mapname(int index, const char* value) {
  mapname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MapList.mapname)
}
 void MapList::set_mapname(int index, const char* value, size_t size) {
  mapname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapList.mapname)
}
 ::std::string* MapList::add_mapname() {
  // @@protoc_insertion_point(field_add_mutable:MapList.mapname)
  return mapname_.Add();
}
 void MapList::add_mapname(const ::std::string& value) {
  mapname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MapList.mapname)
}
 void MapList::add_mapname(const char* value) {
  mapname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MapList.mapname)
}
 void MapList::add_mapname(const char* value, size_t size) {
  mapname_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MapList.mapname)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapList::mapname() const {
  // @@protoc_insertion_point(field_list:MapList.mapname)
  return mapname_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
MapList::mutable_mapname() {
  // @@protoc_insertion_point(field_mutable_list:MapList.mapname)
  return &mapname_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* RobotRequest_Wants_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotRequest_Wants_descriptor_;
}
bool RobotRequest_Wants_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RobotRequest_Wants RobotRequest::NONE;
const RobotRequest_Wants RobotRequest::POS;
const RobotRequest_Wants RobotRequest::MAP;
const RobotRequest_Wants RobotRequest::TRAIL;
const RobotRequest_Wants RobotRequest::Wants_MIN;
const RobotRequest_Wants RobotRequest::Wants_MAX;
const int RobotRequest::Wants_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* RobotRequest_Action_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotRequest_Action_descriptor_;
}
bool RobotRequest_Action_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RobotRequest_Action RobotRequest::NOOP;
const RobotRequest_Action RobotRequest::POINT_APPLY;
const RobotRequest_Action RobotRequest::NAVIGATION;
const RobotRequest_Action RobotRequest::INIT_ORIGIN;
const RobotRequest_Action RobotRequest::CREAT_MAP;
const RobotRequest_Action RobotRequest::FINISH_MAP;
const RobotRequest_Action RobotRequest::UPLOAD_MAP;
const RobotRequest_Action RobotRequest::DOWNLOAD_MAP;
const RobotRequest_Action RobotRequest::CHOICE_MAP;
const RobotRequest_Action RobotRequest::Action_MIN;
const RobotRequest_Action RobotRequest::Action_MAX;
const int RobotRequest::Action_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RobotRequest::kTokenFieldNumber;
const int RobotRequest::kWantsFieldNumber;
const int RobotRequest::kActionFieldNumber;
const int RobotRequest::kDriveFieldNumber;
const int RobotRequest::kPointFieldNumber;
const int RobotRequest::kOriginFieldNumber;
const int RobotRequest::kConfirmFieldNumber;
const int RobotRequest::kMapnameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RobotRequest::RobotRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RobotRequest)
}

void RobotRequest::InitAsDefaultInstance() {
  drive_ = const_cast< ::RobotDrive*>(&::RobotDrive::default_instance());
  origin_ = const_cast< ::OriginPoint*>(&::OriginPoint::default_instance());
}

RobotRequest::RobotRequest(const RobotRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RobotRequest)
}

void RobotRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  wants_ = 0;
  action_ = 0;
  drive_ = NULL;
  origin_ = NULL;
  confirm_ = 0;
  mapname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotRequest::~RobotRequest() {
  // @@protoc_insertion_point(destructor:RobotRequest)
  SharedDtor();
}

void RobotRequest::SharedDtor() {
  token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mapname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete drive_;
    delete origin_;
  }
}

void RobotRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotRequest_descriptor_;
}

const RobotRequest& RobotRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

RobotRequest* RobotRequest::default_instance_ = NULL;

RobotRequest* RobotRequest::New(::google::protobuf::Arena* arena) const {
  RobotRequest* n = new RobotRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RobotRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotRequest)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RobotRequest, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RobotRequest*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 239u) {
    ZR_(wants_, action_);
    if (has_token()) {
      token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_drive()) {
      if (drive_ != NULL) drive_->::RobotDrive::Clear();
    }
    if (has_origin()) {
      if (origin_ != NULL) origin_->::OriginPoint::Clear();
    }
    confirm_ = 0;
    if (has_mapname()) {
      mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  point_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RobotRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RobotRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes token = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_token()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_wants;
        break;
      }

      // required int32 wants = 2;
      case 2: {
        if (tag == 16) {
         parse_wants:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &wants_)));
          set_has_wants();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_action;
        break;
      }

      // required int32 action = 3;
      case 3: {
        if (tag == 24) {
         parse_action:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &action_)));
          set_has_action();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_drive;
        break;
      }

      // optional .RobotDrive drive = 4;
      case 4: {
        if (tag == 34) {
         parse_drive:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_drive()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_point;
        break;
      }

      // repeated .MitionPoint point = 5;
      case 5: {
        if (tag == 42) {
         parse_point:
          DO_(input->IncrementRecursionDepth());
         parse_loop_point:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_point()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_point;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(50)) goto parse_origin;
        break;
      }

      // optional .OriginPoint origin = 6;
      case 6: {
        if (tag == 50) {
         parse_origin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_origin()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_confirm;
        break;
      }

      // optional int32 confirm = 7;
      case 7: {
        if (tag == 56) {
         parse_confirm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &confirm_)));
          set_has_confirm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_mapname;
        break;
      }

      // optional string mapname = 8;
      case 8: {
        if (tag == 66) {
         parse_mapname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mapname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->mapname().data(), this->mapname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "RobotRequest.mapname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RobotRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RobotRequest)
  return false;
#undef DO_
}

void RobotRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RobotRequest)
  // required bytes token = 1;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->token(), output);
  }

  // required int32 wants = 2;
  if (has_wants()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->wants(), output);
  }

  // required int32 action = 3;
  if (has_action()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->action(), output);
  }

  // optional .RobotDrive drive = 4;
  if (has_drive()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->drive_, output);
  }

  // repeated .MitionPoint point = 5;
  for (unsigned int i = 0, n = this->point_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->point(i), output);
  }

  // optional .OriginPoint origin = 6;
  if (has_origin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->origin_, output);
  }

  // optional int32 confirm = 7;
  if (has_confirm()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->confirm(), output);
  }

  // optional string mapname = 8;
  if (has_mapname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mapname().data(), this->mapname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RobotRequest.mapname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->mapname(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RobotRequest)
}

::google::protobuf::uint8* RobotRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotRequest)
  // required bytes token = 1;
  if (has_token()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->token(), target);
  }

  // required int32 wants = 2;
  if (has_wants()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->wants(), target);
  }

  // required int32 action = 3;
  if (has_action()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->action(), target);
  }

  // optional .RobotDrive drive = 4;
  if (has_drive()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->drive_, false, target);
  }

  // repeated .MitionPoint point = 5;
  for (unsigned int i = 0, n = this->point_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->point(i), false, target);
  }

  // optional .OriginPoint origin = 6;
  if (has_origin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->origin_, false, target);
  }

  // optional int32 confirm = 7;
  if (has_confirm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(7, this->confirm(), target);
  }

  // optional string mapname = 8;
  if (has_mapname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->mapname().data(), this->mapname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RobotRequest.mapname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->mapname(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotRequest)
  return target;
}

int RobotRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RobotRequest)
  int total_size = 0;

  if (has_token()) {
    // required bytes token = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->token());
  }

  if (has_wants()) {
    // required int32 wants = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->wants());
  }

  if (has_action()) {
    // required int32 action = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->action());
  }

  return total_size;
}
int RobotRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RobotRequest)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes token = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->token());

    // required int32 wants = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->wants());

    // required int32 action = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->action());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[3 / 32] & 232u) {
    // optional .RobotDrive drive = 4;
    if (has_drive()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->drive_);
    }

    // optional .OriginPoint origin = 6;
    if (has_origin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->origin_);
    }

    // optional int32 confirm = 7;
    if (has_confirm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->confirm());
    }

    // optional string mapname = 8;
    if (has_mapname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mapname());
    }

  }
  // repeated .MitionPoint point = 5;
  total_size += 1 * this->point_size();
  for (int i = 0; i < this->point_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->point(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RobotRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RobotRequest* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RobotRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RobotRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RobotRequest)
    MergeFrom(*source);
  }
}

void RobotRequest::MergeFrom(const RobotRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  point_.MergeFrom(from.point_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_token()) {
      set_has_token();
      token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.token_);
    }
    if (from.has_wants()) {
      set_wants(from.wants());
    }
    if (from.has_action()) {
      set_action(from.action());
    }
    if (from.has_drive()) {
      mutable_drive()->::RobotDrive::MergeFrom(from.drive());
    }
    if (from.has_origin()) {
      mutable_origin()->::OriginPoint::MergeFrom(from.origin());
    }
    if (from.has_confirm()) {
      set_confirm(from.confirm());
    }
    if (from.has_mapname()) {
      set_has_mapname();
      mapname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mapname_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RobotRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RobotRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotRequest::CopyFrom(const RobotRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_drive()) {
    if (!this->drive_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->point())) return false;
  if (has_origin()) {
    if (!this->origin_->IsInitialized()) return false;
  }
  return true;
}

void RobotRequest::Swap(RobotRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RobotRequest::InternalSwap(RobotRequest* other) {
  token_.Swap(&other->token_);
  std::swap(wants_, other->wants_);
  std::swap(action_, other->action_);
  std::swap(drive_, other->drive_);
  point_.UnsafeArenaSwap(&other->point_);
  std::swap(origin_, other->origin_);
  std::swap(confirm_, other->confirm_);
  mapname_.Swap(&other->mapname_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RobotRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotRequest_descriptor_;
  metadata.reflection = RobotRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RobotRequest

// required bytes token = 1;
bool RobotRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RobotRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
void RobotRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
void RobotRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
 const ::std::string& RobotRequest::token() const {
  // @@protoc_insertion_point(field_get:RobotRequest.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RobotRequest::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RobotRequest.token)
}
 void RobotRequest::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RobotRequest.token)
}
 void RobotRequest::set_token(const void* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RobotRequest.token)
}
 ::std::string* RobotRequest::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:RobotRequest.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RobotRequest::release_token() {
  // @@protoc_insertion_point(field_release:RobotRequest.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RobotRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.token)
}

// required int32 wants = 2;
bool RobotRequest::has_wants() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RobotRequest::set_has_wants() {
  _has_bits_[0] |= 0x00000002u;
}
void RobotRequest::clear_has_wants() {
  _has_bits_[0] &= ~0x00000002u;
}
void RobotRequest::clear_wants() {
  wants_ = 0;
  clear_has_wants();
}
 ::google::protobuf::int32 RobotRequest::wants() const {
  // @@protoc_insertion_point(field_get:RobotRequest.wants)
  return wants_;
}
 void RobotRequest::set_wants(::google::protobuf::int32 value) {
  set_has_wants();
  wants_ = value;
  // @@protoc_insertion_point(field_set:RobotRequest.wants)
}

// required int32 action = 3;
bool RobotRequest::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RobotRequest::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
void RobotRequest::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
void RobotRequest::clear_action() {
  action_ = 0;
  clear_has_action();
}
 ::google::protobuf::int32 RobotRequest::action() const {
  // @@protoc_insertion_point(field_get:RobotRequest.action)
  return action_;
}
 void RobotRequest::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:RobotRequest.action)
}

// optional .RobotDrive drive = 4;
bool RobotRequest::has_drive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RobotRequest::set_has_drive() {
  _has_bits_[0] |= 0x00000008u;
}
void RobotRequest::clear_has_drive() {
  _has_bits_[0] &= ~0x00000008u;
}
void RobotRequest::clear_drive() {
  if (drive_ != NULL) drive_->::RobotDrive::Clear();
  clear_has_drive();
}
const ::RobotDrive& RobotRequest::drive() const {
  // @@protoc_insertion_point(field_get:RobotRequest.drive)
  return drive_ != NULL ? *drive_ : *default_instance_->drive_;
}
::RobotDrive* RobotRequest::mutable_drive() {
  set_has_drive();
  if (drive_ == NULL) {
    drive_ = new ::RobotDrive;
  }
  // @@protoc_insertion_point(field_mutable:RobotRequest.drive)
  return drive_;
}
::RobotDrive* RobotRequest::release_drive() {
  // @@protoc_insertion_point(field_release:RobotRequest.drive)
  clear_has_drive();
  ::RobotDrive* temp = drive_;
  drive_ = NULL;
  return temp;
}
void RobotRequest::set_allocated_drive(::RobotDrive* drive) {
  delete drive_;
  drive_ = drive;
  if (drive) {
    set_has_drive();
  } else {
    clear_has_drive();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.drive)
}

// repeated .MitionPoint point = 5;
int RobotRequest::point_size() const {
  return point_.size();
}
void RobotRequest::clear_point() {
  point_.Clear();
}
const ::MitionPoint& RobotRequest::point(int index) const {
  // @@protoc_insertion_point(field_get:RobotRequest.point)
  return point_.Get(index);
}
::MitionPoint* RobotRequest::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:RobotRequest.point)
  return point_.Mutable(index);
}
::MitionPoint* RobotRequest::add_point() {
  // @@protoc_insertion_point(field_add:RobotRequest.point)
  return point_.Add();
}
::google::protobuf::RepeatedPtrField< ::MitionPoint >*
RobotRequest::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:RobotRequest.point)
  return &point_;
}
const ::google::protobuf::RepeatedPtrField< ::MitionPoint >&
RobotRequest::point() const {
  // @@protoc_insertion_point(field_list:RobotRequest.point)
  return point_;
}

// optional .OriginPoint origin = 6;
bool RobotRequest::has_origin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RobotRequest::set_has_origin() {
  _has_bits_[0] |= 0x00000020u;
}
void RobotRequest::clear_has_origin() {
  _has_bits_[0] &= ~0x00000020u;
}
void RobotRequest::clear_origin() {
  if (origin_ != NULL) origin_->::OriginPoint::Clear();
  clear_has_origin();
}
const ::OriginPoint& RobotRequest::origin() const {
  // @@protoc_insertion_point(field_get:RobotRequest.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
::OriginPoint* RobotRequest::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::OriginPoint;
  }
  // @@protoc_insertion_point(field_mutable:RobotRequest.origin)
  return origin_;
}
::OriginPoint* RobotRequest::release_origin() {
  // @@protoc_insertion_point(field_release:RobotRequest.origin)
  clear_has_origin();
  ::OriginPoint* temp = origin_;
  origin_ = NULL;
  return temp;
}
void RobotRequest::set_allocated_origin(::OriginPoint* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.origin)
}

// optional int32 confirm = 7;
bool RobotRequest::has_confirm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RobotRequest::set_has_confirm() {
  _has_bits_[0] |= 0x00000040u;
}
void RobotRequest::clear_has_confirm() {
  _has_bits_[0] &= ~0x00000040u;
}
void RobotRequest::clear_confirm() {
  confirm_ = 0;
  clear_has_confirm();
}
 ::google::protobuf::int32 RobotRequest::confirm() const {
  // @@protoc_insertion_point(field_get:RobotRequest.confirm)
  return confirm_;
}
 void RobotRequest::set_confirm(::google::protobuf::int32 value) {
  set_has_confirm();
  confirm_ = value;
  // @@protoc_insertion_point(field_set:RobotRequest.confirm)
}

// optional string mapname = 8;
bool RobotRequest::has_mapname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RobotRequest::set_has_mapname() {
  _has_bits_[0] |= 0x00000080u;
}
void RobotRequest::clear_has_mapname() {
  _has_bits_[0] &= ~0x00000080u;
}
void RobotRequest::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mapname();
}
 const ::std::string& RobotRequest::mapname() const {
  // @@protoc_insertion_point(field_get:RobotRequest.mapname)
  return mapname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RobotRequest::set_mapname(const ::std::string& value) {
  set_has_mapname();
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RobotRequest.mapname)
}
 void RobotRequest::set_mapname(const char* value) {
  set_has_mapname();
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RobotRequest.mapname)
}
 void RobotRequest::set_mapname(const char* value, size_t size) {
  set_has_mapname();
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RobotRequest.mapname)
}
 ::std::string* RobotRequest::mutable_mapname() {
  set_has_mapname();
  // @@protoc_insertion_point(field_mutable:RobotRequest.mapname)
  return mapname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RobotRequest::release_mapname() {
  // @@protoc_insertion_point(field_release:RobotRequest.mapname)
  clear_has_mapname();
  return mapname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RobotRequest::set_allocated_mapname(::std::string* mapname) {
  if (mapname != NULL) {
    set_has_mapname();
  } else {
    clear_has_mapname();
  }
  mapname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.mapname)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* RobotMap_Grid_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotMap_Grid_descriptor_;
}
bool RobotMap_Grid_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RobotMap_Grid RobotMap::UNKOWN;
const RobotMap_Grid RobotMap::FREE;
const RobotMap_Grid RobotMap::OCCUPIED;
const RobotMap_Grid RobotMap::FEATURE;
const RobotMap_Grid RobotMap::Grid_MIN;
const RobotMap_Grid RobotMap::Grid_MAX;
const int RobotMap::Grid_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RobotMap::kOriginXFieldNumber;
const int RobotMap::kOriginYFieldNumber;
const int RobotMap::kSizeFieldNumber;
const int RobotMap::kGridsXFieldNumber;
const int RobotMap::kGridsYFieldNumber;
const int RobotMap::kZgridsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RobotMap::RobotMap()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RobotMap)
}

void RobotMap::InitAsDefaultInstance() {
}

RobotMap::RobotMap(const RobotMap& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RobotMap)
}

void RobotMap::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  origin_x_ = 0;
  origin_y_ = 0;
  size_ = 0;
  grids_x_ = 0;
  grids_y_ = 0;
  zgrids_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotMap::~RobotMap() {
  // @@protoc_insertion_point(destructor:RobotMap)
  SharedDtor();
}

void RobotMap::SharedDtor() {
  zgrids_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RobotMap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotMap_descriptor_;
}

const RobotMap& RobotMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

RobotMap* RobotMap::default_instance_ = NULL;

RobotMap* RobotMap::New(::google::protobuf::Arena* arena) const {
  RobotMap* n = new RobotMap;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RobotMap::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotMap)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RobotMap, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RobotMap*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(origin_x_, grids_x_);
    grids_y_ = 0;
    if (has_zgrids()) {
      zgrids_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RobotMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RobotMap)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double origin_x = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &origin_x_)));
          set_has_origin_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_origin_y;
        break;
      }

      // required double origin_y = 2;
      case 2: {
        if (tag == 17) {
         parse_origin_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &origin_y_)));
          set_has_origin_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_size;
        break;
      }

      // required int32 size = 3;
      case 3: {
        if (tag == 24) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_grids_x;
        break;
      }

      // required int32 grids_x = 4;
      case 4: {
        if (tag == 32) {
         parse_grids_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &grids_x_)));
          set_has_grids_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_grids_y;
        break;
      }

      // required int32 grids_y = 5;
      case 5: {
        if (tag == 40) {
         parse_grids_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &grids_y_)));
          set_has_grids_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_zgrids;
        break;
      }

      // required bytes zgrids = 6;
      case 6: {
        if (tag == 50) {
         parse_zgrids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_zgrids()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RobotMap)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RobotMap)
  return false;
#undef DO_
}

void RobotMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RobotMap)
  // required double origin_x = 1;
  if (has_origin_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->origin_x(), output);
  }

  // required double origin_y = 2;
  if (has_origin_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->origin_y(), output);
  }

  // required int32 size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->size(), output);
  }

  // required int32 grids_x = 4;
  if (has_grids_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->grids_x(), output);
  }

  // required int32 grids_y = 5;
  if (has_grids_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->grids_y(), output);
  }

  // required bytes zgrids = 6;
  if (has_zgrids()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->zgrids(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RobotMap)
}

::google::protobuf::uint8* RobotMap::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotMap)
  // required double origin_x = 1;
  if (has_origin_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->origin_x(), target);
  }

  // required double origin_y = 2;
  if (has_origin_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->origin_y(), target);
  }

  // required int32 size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->size(), target);
  }

  // required int32 grids_x = 4;
  if (has_grids_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->grids_x(), target);
  }

  // required int32 grids_y = 5;
  if (has_grids_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->grids_y(), target);
  }

  // required bytes zgrids = 6;
  if (has_zgrids()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->zgrids(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotMap)
  return target;
}

int RobotMap::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RobotMap)
  int total_size = 0;

  if (has_origin_x()) {
    // required double origin_x = 1;
    total_size += 1 + 8;
  }

  if (has_origin_y()) {
    // required double origin_y = 2;
    total_size += 1 + 8;
  }

  if (has_size()) {
    // required int32 size = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->size());
  }

  if (has_grids_x()) {
    // required int32 grids_x = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->grids_x());
  }

  if (has_grids_y()) {
    // required int32 grids_y = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->grids_y());
  }

  if (has_zgrids()) {
    // required bytes zgrids = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->zgrids());
  }

  return total_size;
}
int RobotMap::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RobotMap)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required double origin_x = 1;
    total_size += 1 + 8;

    // required double origin_y = 2;
    total_size += 1 + 8;

    // required int32 size = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->size());

    // required int32 grids_x = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->grids_x());

    // required int32 grids_y = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->grids_y());

    // required bytes zgrids = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->zgrids());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotMap::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RobotMap)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RobotMap* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RobotMap>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RobotMap)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RobotMap)
    MergeFrom(*source);
  }
}

void RobotMap::MergeFrom(const RobotMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotMap)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_origin_x()) {
      set_origin_x(from.origin_x());
    }
    if (from.has_origin_y()) {
      set_origin_y(from.origin_y());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_grids_x()) {
      set_grids_x(from.grids_x());
    }
    if (from.has_grids_y()) {
      set_grids_y(from.grids_y());
    }
    if (from.has_zgrids()) {
      set_has_zgrids();
      zgrids_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.zgrids_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RobotMap::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RobotMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotMap::CopyFrom(const RobotMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotMap::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void RobotMap::Swap(RobotMap* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RobotMap::InternalSwap(RobotMap* other) {
  std::swap(origin_x_, other->origin_x_);
  std::swap(origin_y_, other->origin_y_);
  std::swap(size_, other->size_);
  std::swap(grids_x_, other->grids_x_);
  std::swap(grids_y_, other->grids_y_);
  zgrids_.Swap(&other->zgrids_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RobotMap::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotMap_descriptor_;
  metadata.reflection = RobotMap_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RobotMap

// required double origin_x = 1;
bool RobotMap::has_origin_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RobotMap::set_has_origin_x() {
  _has_bits_[0] |= 0x00000001u;
}
void RobotMap::clear_has_origin_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void RobotMap::clear_origin_x() {
  origin_x_ = 0;
  clear_has_origin_x();
}
 double RobotMap::origin_x() const {
  // @@protoc_insertion_point(field_get:RobotMap.origin_x)
  return origin_x_;
}
 void RobotMap::set_origin_x(double value) {
  set_has_origin_x();
  origin_x_ = value;
  // @@protoc_insertion_point(field_set:RobotMap.origin_x)
}

// required double origin_y = 2;
bool RobotMap::has_origin_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RobotMap::set_has_origin_y() {
  _has_bits_[0] |= 0x00000002u;
}
void RobotMap::clear_has_origin_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void RobotMap::clear_origin_y() {
  origin_y_ = 0;
  clear_has_origin_y();
}
 double RobotMap::origin_y() const {
  // @@protoc_insertion_point(field_get:RobotMap.origin_y)
  return origin_y_;
}
 void RobotMap::set_origin_y(double value) {
  set_has_origin_y();
  origin_y_ = value;
  // @@protoc_insertion_point(field_set:RobotMap.origin_y)
}

// required int32 size = 3;
bool RobotMap::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RobotMap::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
void RobotMap::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
void RobotMap::clear_size() {
  size_ = 0;
  clear_has_size();
}
 ::google::protobuf::int32 RobotMap::size() const {
  // @@protoc_insertion_point(field_get:RobotMap.size)
  return size_;
}
 void RobotMap::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:RobotMap.size)
}

// required int32 grids_x = 4;
bool RobotMap::has_grids_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RobotMap::set_has_grids_x() {
  _has_bits_[0] |= 0x00000008u;
}
void RobotMap::clear_has_grids_x() {
  _has_bits_[0] &= ~0x00000008u;
}
void RobotMap::clear_grids_x() {
  grids_x_ = 0;
  clear_has_grids_x();
}
 ::google::protobuf::int32 RobotMap::grids_x() const {
  // @@protoc_insertion_point(field_get:RobotMap.grids_x)
  return grids_x_;
}
 void RobotMap::set_grids_x(::google::protobuf::int32 value) {
  set_has_grids_x();
  grids_x_ = value;
  // @@protoc_insertion_point(field_set:RobotMap.grids_x)
}

// required int32 grids_y = 5;
bool RobotMap::has_grids_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RobotMap::set_has_grids_y() {
  _has_bits_[0] |= 0x00000010u;
}
void RobotMap::clear_has_grids_y() {
  _has_bits_[0] &= ~0x00000010u;
}
void RobotMap::clear_grids_y() {
  grids_y_ = 0;
  clear_has_grids_y();
}
 ::google::protobuf::int32 RobotMap::grids_y() const {
  // @@protoc_insertion_point(field_get:RobotMap.grids_y)
  return grids_y_;
}
 void RobotMap::set_grids_y(::google::protobuf::int32 value) {
  set_has_grids_y();
  grids_y_ = value;
  // @@protoc_insertion_point(field_set:RobotMap.grids_y)
}

// required bytes zgrids = 6;
bool RobotMap::has_zgrids() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RobotMap::set_has_zgrids() {
  _has_bits_[0] |= 0x00000020u;
}
void RobotMap::clear_has_zgrids() {
  _has_bits_[0] &= ~0x00000020u;
}
void RobotMap::clear_zgrids() {
  zgrids_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_zgrids();
}
 const ::std::string& RobotMap::zgrids() const {
  // @@protoc_insertion_point(field_get:RobotMap.zgrids)
  return zgrids_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RobotMap::set_zgrids(const ::std::string& value) {
  set_has_zgrids();
  zgrids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RobotMap.zgrids)
}
 void RobotMap::set_zgrids(const char* value) {
  set_has_zgrids();
  zgrids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RobotMap.zgrids)
}
 void RobotMap::set_zgrids(const void* value, size_t size) {
  set_has_zgrids();
  zgrids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RobotMap.zgrids)
}
 ::std::string* RobotMap::mutable_zgrids() {
  set_has_zgrids();
  // @@protoc_insertion_point(field_mutable:RobotMap.zgrids)
  return zgrids_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RobotMap::release_zgrids() {
  // @@protoc_insertion_point(field_release:RobotMap.zgrids)
  clear_has_zgrids();
  return zgrids_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RobotMap::set_allocated_zgrids(::std::string* zgrids) {
  if (zgrids != NULL) {
    set_has_zgrids();
  } else {
    clear_has_zgrids();
  }
  zgrids_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), zgrids);
  // @@protoc_insertion_point(field_set_allocated:RobotMap.zgrids)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RobotPos::kOffsetXFieldNumber;
const int RobotPos::kOffsetYFieldNumber;
const int RobotPos::kAngleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RobotPos::RobotPos()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RobotPos)
}

void RobotPos::InitAsDefaultInstance() {
}

RobotPos::RobotPos(const RobotPos& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RobotPos)
}

void RobotPos::SharedCtor() {
  _cached_size_ = 0;
  offset_x_ = 0;
  offset_y_ = 0;
  angle_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotPos::~RobotPos() {
  // @@protoc_insertion_point(destructor:RobotPos)
  SharedDtor();
}

void RobotPos::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobotPos::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotPos::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotPos_descriptor_;
}

const RobotPos& RobotPos::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

RobotPos* RobotPos::default_instance_ = NULL;

RobotPos* RobotPos::New(::google::protobuf::Arena* arena) const {
  RobotPos* n = new RobotPos;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RobotPos::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotPos)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RobotPos, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RobotPos*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(offset_x_, angle_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RobotPos::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RobotPos)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float offset_x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &offset_x_)));
          set_has_offset_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_offset_y;
        break;
      }

      // required float offset_y = 2;
      case 2: {
        if (tag == 21) {
         parse_offset_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &offset_y_)));
          set_has_offset_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_angle;
        break;
      }

      // optional float angle = 3;
      case 3: {
        if (tag == 29) {
         parse_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
          set_has_angle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RobotPos)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RobotPos)
  return false;
#undef DO_
}

void RobotPos::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RobotPos)
  // required float offset_x = 1;
  if (has_offset_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->offset_x(), output);
  }

  // required float offset_y = 2;
  if (has_offset_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->offset_y(), output);
  }

  // optional float angle = 3;
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->angle(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RobotPos)
}

::google::protobuf::uint8* RobotPos::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotPos)
  // required float offset_x = 1;
  if (has_offset_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->offset_x(), target);
  }

  // required float offset_y = 2;
  if (has_offset_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->offset_y(), target);
  }

  // optional float angle = 3;
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->angle(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotPos)
  return target;
}

int RobotPos::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RobotPos)
  int total_size = 0;

  if (has_offset_x()) {
    // required float offset_x = 1;
    total_size += 1 + 4;
  }

  if (has_offset_y()) {
    // required float offset_y = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
int RobotPos::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RobotPos)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required float offset_x = 1;
    total_size += 1 + 4;

    // required float offset_y = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional float angle = 3;
  if (has_angle()) {
    total_size += 1 + 4;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotPos::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RobotPos)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RobotPos* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RobotPos>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RobotPos)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RobotPos)
    MergeFrom(*source);
  }
}

void RobotPos::MergeFrom(const RobotPos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotPos)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offset_x()) {
      set_offset_x(from.offset_x());
    }
    if (from.has_offset_y()) {
      set_offset_y(from.offset_y());
    }
    if (from.has_angle()) {
      set_angle(from.angle());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RobotPos::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RobotPos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotPos::CopyFrom(const RobotPos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotPos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotPos::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RobotPos::Swap(RobotPos* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RobotPos::InternalSwap(RobotPos* other) {
  std::swap(offset_x_, other->offset_x_);
  std::swap(offset_y_, other->offset_y_);
  std::swap(angle_, other->angle_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RobotPos::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotPos_descriptor_;
  metadata.reflection = RobotPos_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RobotPos

// required float offset_x = 1;
bool RobotPos::has_offset_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RobotPos::set_has_offset_x() {
  _has_bits_[0] |= 0x00000001u;
}
void RobotPos::clear_has_offset_x() {
  _has_bits_[0] &= ~0x00000001u;
}
void RobotPos::clear_offset_x() {
  offset_x_ = 0;
  clear_has_offset_x();
}
 float RobotPos::offset_x() const {
  // @@protoc_insertion_point(field_get:RobotPos.offset_x)
  return offset_x_;
}
 void RobotPos::set_offset_x(float value) {
  set_has_offset_x();
  offset_x_ = value;
  // @@protoc_insertion_point(field_set:RobotPos.offset_x)
}

// required float offset_y = 2;
bool RobotPos::has_offset_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RobotPos::set_has_offset_y() {
  _has_bits_[0] |= 0x00000002u;
}
void RobotPos::clear_has_offset_y() {
  _has_bits_[0] &= ~0x00000002u;
}
void RobotPos::clear_offset_y() {
  offset_y_ = 0;
  clear_has_offset_y();
}
 float RobotPos::offset_y() const {
  // @@protoc_insertion_point(field_get:RobotPos.offset_y)
  return offset_y_;
}
 void RobotPos::set_offset_y(float value) {
  set_has_offset_y();
  offset_y_ = value;
  // @@protoc_insertion_point(field_set:RobotPos.offset_y)
}

// optional float angle = 3;
bool RobotPos::has_angle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RobotPos::set_has_angle() {
  _has_bits_[0] |= 0x00000004u;
}
void RobotPos::clear_has_angle() {
  _has_bits_[0] &= ~0x00000004u;
}
void RobotPos::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
 float RobotPos::angle() const {
  // @@protoc_insertion_point(field_get:RobotPos.angle)
  return angle_;
}
 void RobotPos::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:RobotPos.angle)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RobotTrail::kTrailFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RobotTrail::RobotTrail()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RobotTrail)
}

void RobotTrail::InitAsDefaultInstance() {
}

RobotTrail::RobotTrail(const RobotTrail& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RobotTrail)
}

void RobotTrail::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotTrail::~RobotTrail() {
  // @@protoc_insertion_point(destructor:RobotTrail)
  SharedDtor();
}

void RobotTrail::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobotTrail::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotTrail::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotTrail_descriptor_;
}

const RobotTrail& RobotTrail::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

RobotTrail* RobotTrail::default_instance_ = NULL;

RobotTrail* RobotTrail::New(::google::protobuf::Arena* arena) const {
  RobotTrail* n = new RobotTrail;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RobotTrail::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotTrail)
  trail_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RobotTrail::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RobotTrail)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .RobotPos trail = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_trail:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_trail()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_trail;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RobotTrail)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RobotTrail)
  return false;
#undef DO_
}

void RobotTrail::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RobotTrail)
  // repeated .RobotPos trail = 1;
  for (unsigned int i = 0, n = this->trail_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->trail(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RobotTrail)
}

::google::protobuf::uint8* RobotTrail::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotTrail)
  // repeated .RobotPos trail = 1;
  for (unsigned int i = 0, n = this->trail_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->trail(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotTrail)
  return target;
}

int RobotTrail::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RobotTrail)
  int total_size = 0;

  // repeated .RobotPos trail = 1;
  total_size += 1 * this->trail_size();
  for (int i = 0; i < this->trail_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->trail(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotTrail::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RobotTrail)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RobotTrail* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RobotTrail>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RobotTrail)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RobotTrail)
    MergeFrom(*source);
  }
}

void RobotTrail::MergeFrom(const RobotTrail& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotTrail)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  trail_.MergeFrom(from.trail_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RobotTrail::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RobotTrail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotTrail::CopyFrom(const RobotTrail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotTrail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotTrail::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->trail())) return false;
  return true;
}

void RobotTrail::Swap(RobotTrail* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RobotTrail::InternalSwap(RobotTrail* other) {
  trail_.UnsafeArenaSwap(&other->trail_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RobotTrail::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotTrail_descriptor_;
  metadata.reflection = RobotTrail_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RobotTrail

// repeated .RobotPos trail = 1;
int RobotTrail::trail_size() const {
  return trail_.size();
}
void RobotTrail::clear_trail() {
  trail_.Clear();
}
const ::RobotPos& RobotTrail::trail(int index) const {
  // @@protoc_insertion_point(field_get:RobotTrail.trail)
  return trail_.Get(index);
}
::RobotPos* RobotTrail::mutable_trail(int index) {
  // @@protoc_insertion_point(field_mutable:RobotTrail.trail)
  return trail_.Mutable(index);
}
::RobotPos* RobotTrail::add_trail() {
  // @@protoc_insertion_point(field_add:RobotTrail.trail)
  return trail_.Add();
}
::google::protobuf::RepeatedPtrField< ::RobotPos >*
RobotTrail::mutable_trail() {
  // @@protoc_insertion_point(field_mutable_list:RobotTrail.trail)
  return &trail_;
}
const ::google::protobuf::RepeatedPtrField< ::RobotPos >&
RobotTrail::trail() const {
  // @@protoc_insertion_point(field_list:RobotTrail.trail)
  return trail_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RobotInfo::kSpeedFieldNumber;
const int RobotInfo::kVoltageFieldNumber;
const int RobotInfo::kCurXFieldNumber;
const int RobotInfo::kCurYFieldNumber;
const int RobotInfo::kCurYawFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RobotInfo::RobotInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RobotInfo)
}

void RobotInfo::InitAsDefaultInstance() {
}

RobotInfo::RobotInfo(const RobotInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RobotInfo)
}

void RobotInfo::SharedCtor() {
  _cached_size_ = 0;
  speed_ = 0;
  voltage_ = 0;
  cur_x_ = 0;
  cur_y_ = 0;
  cur_yaw_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotInfo::~RobotInfo() {
  // @@protoc_insertion_point(destructor:RobotInfo)
  SharedDtor();
}

void RobotInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RobotInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotInfo_descriptor_;
}

const RobotInfo& RobotInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

RobotInfo* RobotInfo::default_instance_ = NULL;

RobotInfo* RobotInfo::New(::google::protobuf::Arena* arena) const {
  RobotInfo* n = new RobotInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RobotInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RobotInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RobotInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(speed_, cur_yaw_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RobotInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RobotInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float speed = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));
          set_has_speed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_voltage;
        break;
      }

      // required float voltage = 2;
      case 2: {
        if (tag == 21) {
         parse_voltage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &voltage_)));
          set_has_voltage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_cur_x;
        break;
      }

      // required float cur_x = 3;
      case 3: {
        if (tag == 29) {
         parse_cur_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cur_x_)));
          set_has_cur_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_cur_y;
        break;
      }

      // required float cur_y = 4;
      case 4: {
        if (tag == 37) {
         parse_cur_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cur_y_)));
          set_has_cur_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_cur_yaw;
        break;
      }

      // required float cur_yaw = 5;
      case 5: {
        if (tag == 45) {
         parse_cur_yaw:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cur_yaw_)));
          set_has_cur_yaw();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RobotInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RobotInfo)
  return false;
#undef DO_
}

void RobotInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RobotInfo)
  // required float speed = 1;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->speed(), output);
  }

  // required float voltage = 2;
  if (has_voltage()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->voltage(), output);
  }

  // required float cur_x = 3;
  if (has_cur_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->cur_x(), output);
  }

  // required float cur_y = 4;
  if (has_cur_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->cur_y(), output);
  }

  // required float cur_yaw = 5;
  if (has_cur_yaw()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->cur_yaw(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RobotInfo)
}

::google::protobuf::uint8* RobotInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotInfo)
  // required float speed = 1;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->speed(), target);
  }

  // required float voltage = 2;
  if (has_voltage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->voltage(), target);
  }

  // required float cur_x = 3;
  if (has_cur_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->cur_x(), target);
  }

  // required float cur_y = 4;
  if (has_cur_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->cur_y(), target);
  }

  // required float cur_yaw = 5;
  if (has_cur_yaw()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->cur_yaw(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotInfo)
  return target;
}

int RobotInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:RobotInfo)
  int total_size = 0;

  if (has_speed()) {
    // required float speed = 1;
    total_size += 1 + 4;
  }

  if (has_voltage()) {
    // required float voltage = 2;
    total_size += 1 + 4;
  }

  if (has_cur_x()) {
    // required float cur_x = 3;
    total_size += 1 + 4;
  }

  if (has_cur_y()) {
    // required float cur_y = 4;
    total_size += 1 + 4;
  }

  if (has_cur_yaw()) {
    // required float cur_yaw = 5;
    total_size += 1 + 4;
  }

  return total_size;
}
int RobotInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RobotInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required float speed = 1;
    total_size += 1 + 4;

    // required float voltage = 2;
    total_size += 1 + 4;

    // required float cur_x = 3;
    total_size += 1 + 4;

    // required float cur_y = 4;
    total_size += 1 + 4;

    // required float cur_yaw = 5;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RobotInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RobotInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RobotInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RobotInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RobotInfo)
    MergeFrom(*source);
  }
}

void RobotInfo::MergeFrom(const RobotInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_speed()) {
      set_speed(from.speed());
    }
    if (from.has_voltage()) {
      set_voltage(from.voltage());
    }
    if (from.has_cur_x()) {
      set_cur_x(from.cur_x());
    }
    if (from.has_cur_y()) {
      set_cur_y(from.cur_y());
    }
    if (from.has_cur_yaw()) {
      set_cur_yaw(from.cur_yaw());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RobotInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RobotInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotInfo::CopyFrom(const RobotInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void RobotInfo::Swap(RobotInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RobotInfo::InternalSwap(RobotInfo* other) {
  std::swap(speed_, other->speed_);
  std::swap(voltage_, other->voltage_);
  std::swap(cur_x_, other->cur_x_);
  std::swap(cur_y_, other->cur_y_);
  std::swap(cur_yaw_, other->cur_yaw_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RobotInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotInfo_descriptor_;
  metadata.reflection = RobotInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RobotInfo

// required float speed = 1;
bool RobotInfo::has_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RobotInfo::set_has_speed() {
  _has_bits_[0] |= 0x00000001u;
}
void RobotInfo::clear_has_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
void RobotInfo::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
 float RobotInfo::speed() const {
  // @@protoc_insertion_point(field_get:RobotInfo.speed)
  return speed_;
}
 void RobotInfo::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:RobotInfo.speed)
}

// required float voltage = 2;
bool RobotInfo::has_voltage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RobotInfo::set_has_voltage() {
  _has_bits_[0] |= 0x00000002u;
}
void RobotInfo::clear_has_voltage() {
  _has_bits_[0] &= ~0x00000002u;
}
void RobotInfo::clear_voltage() {
  voltage_ = 0;
  clear_has_voltage();
}
 float RobotInfo::voltage() const {
  // @@protoc_insertion_point(field_get:RobotInfo.voltage)
  return voltage_;
}
 void RobotInfo::set_voltage(float value) {
  set_has_voltage();
  voltage_ = value;
  // @@protoc_insertion_point(field_set:RobotInfo.voltage)
}

// required float cur_x = 3;
bool RobotInfo::has_cur_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RobotInfo::set_has_cur_x() {
  _has_bits_[0] |= 0x00000004u;
}
void RobotInfo::clear_has_cur_x() {
  _has_bits_[0] &= ~0x00000004u;
}
void RobotInfo::clear_cur_x() {
  cur_x_ = 0;
  clear_has_cur_x();
}
 float RobotInfo::cur_x() const {
  // @@protoc_insertion_point(field_get:RobotInfo.cur_x)
  return cur_x_;
}
 void RobotInfo::set_cur_x(float value) {
  set_has_cur_x();
  cur_x_ = value;
  // @@protoc_insertion_point(field_set:RobotInfo.cur_x)
}

// required float cur_y = 4;
bool RobotInfo::has_cur_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RobotInfo::set_has_cur_y() {
  _has_bits_[0] |= 0x00000008u;
}
void RobotInfo::clear_has_cur_y() {
  _has_bits_[0] &= ~0x00000008u;
}
void RobotInfo::clear_cur_y() {
  cur_y_ = 0;
  clear_has_cur_y();
}
 float RobotInfo::cur_y() const {
  // @@protoc_insertion_point(field_get:RobotInfo.cur_y)
  return cur_y_;
}
 void RobotInfo::set_cur_y(float value) {
  set_has_cur_y();
  cur_y_ = value;
  // @@protoc_insertion_point(field_set:RobotInfo.cur_y)
}

// required float cur_yaw = 5;
bool RobotInfo::has_cur_yaw() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RobotInfo::set_has_cur_yaw() {
  _has_bits_[0] |= 0x00000010u;
}
void RobotInfo::clear_has_cur_yaw() {
  _has_bits_[0] &= ~0x00000010u;
}
void RobotInfo::clear_cur_yaw() {
  cur_yaw_ = 0;
  clear_has_cur_yaw();
}
 float RobotInfo::cur_yaw() const {
  // @@protoc_insertion_point(field_get:RobotInfo.cur_yaw)
  return cur_yaw_;
}
 void RobotInfo::set_cur_yaw(float value) {
  set_has_cur_yaw();
  cur_yaw_ = value;
  // @@protoc_insertion_point(field_set:RobotInfo.cur_yaw)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MitionStatus::kMitionNumberFieldNumber;
const int MitionStatus::kMitionFinishFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MitionStatus::MitionStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:MitionStatus)
}

void MitionStatus::InitAsDefaultInstance() {
}

MitionStatus::MitionStatus(const MitionStatus& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:MitionStatus)
}

void MitionStatus::SharedCtor() {
  _cached_size_ = 0;
  mition_number_ = 0;
  mition_finish_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MitionStatus::~MitionStatus() {
  // @@protoc_insertion_point(destructor:MitionStatus)
  SharedDtor();
}

void MitionStatus::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MitionStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MitionStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MitionStatus_descriptor_;
}

const MitionStatus& MitionStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

MitionStatus* MitionStatus::default_instance_ = NULL;

MitionStatus* MitionStatus::New(::google::protobuf::Arena* arena) const {
  MitionStatus* n = new MitionStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MitionStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:MitionStatus)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(MitionStatus, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MitionStatus*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(mition_number_, mition_finish_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MitionStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:MitionStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 mition_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &mition_number_)));
          set_has_mition_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_mition_finish;
        break;
      }

      // required bool mition_finish = 2;
      case 2: {
        if (tag == 16) {
         parse_mition_finish:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &mition_finish_)));
          set_has_mition_finish();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:MitionStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:MitionStatus)
  return false;
#undef DO_
}

void MitionStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:MitionStatus)
  // required int32 mition_number = 1;
  if (has_mition_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->mition_number(), output);
  }

  // required bool mition_finish = 2;
  if (has_mition_finish()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->mition_finish(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:MitionStatus)
}

::google::protobuf::uint8* MitionStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:MitionStatus)
  // required int32 mition_number = 1;
  if (has_mition_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->mition_number(), target);
  }

  // required bool mition_finish = 2;
  if (has_mition_finish()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->mition_finish(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:MitionStatus)
  return target;
}

int MitionStatus::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:MitionStatus)
  int total_size = 0;

  if (has_mition_number()) {
    // required int32 mition_number = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->mition_number());
  }

  if (has_mition_finish()) {
    // required bool mition_finish = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
int MitionStatus::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:MitionStatus)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 mition_number = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->mition_number());

    // required bool mition_finish = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MitionStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:MitionStatus)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MitionStatus* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MitionStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:MitionStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:MitionStatus)
    MergeFrom(*source);
  }
}

void MitionStatus::MergeFrom(const MitionStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:MitionStatus)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mition_number()) {
      set_mition_number(from.mition_number());
    }
    if (from.has_mition_finish()) {
      set_mition_finish(from.mition_finish());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MitionStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:MitionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MitionStatus::CopyFrom(const MitionStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:MitionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MitionStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MitionStatus::Swap(MitionStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MitionStatus::InternalSwap(MitionStatus* other) {
  std::swap(mition_number_, other->mition_number_);
  std::swap(mition_finish_, other->mition_finish_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MitionStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MitionStatus_descriptor_;
  metadata.reflection = MitionStatus_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MitionStatus

// required int32 mition_number = 1;
bool MitionStatus::has_mition_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MitionStatus::set_has_mition_number() {
  _has_bits_[0] |= 0x00000001u;
}
void MitionStatus::clear_has_mition_number() {
  _has_bits_[0] &= ~0x00000001u;
}
void MitionStatus::clear_mition_number() {
  mition_number_ = 0;
  clear_has_mition_number();
}
 ::google::protobuf::int32 MitionStatus::mition_number() const {
  // @@protoc_insertion_point(field_get:MitionStatus.mition_number)
  return mition_number_;
}
 void MitionStatus::set_mition_number(::google::protobuf::int32 value) {
  set_has_mition_number();
  mition_number_ = value;
  // @@protoc_insertion_point(field_set:MitionStatus.mition_number)
}

// required bool mition_finish = 2;
bool MitionStatus::has_mition_finish() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MitionStatus::set_has_mition_finish() {
  _has_bits_[0] |= 0x00000002u;
}
void MitionStatus::clear_has_mition_finish() {
  _has_bits_[0] &= ~0x00000002u;
}
void MitionStatus::clear_mition_finish() {
  mition_finish_ = false;
  clear_has_mition_finish();
}
 bool MitionStatus::mition_finish() const {
  // @@protoc_insertion_point(field_get:MitionStatus.mition_finish)
  return mition_finish_;
}
 void MitionStatus::set_mition_finish(bool value) {
  set_has_mition_finish();
  mition_finish_ = value;
  // @@protoc_insertion_point(field_set:MitionStatus.mition_finish)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RobotResponse::kCodeFieldNumber;
const int RobotResponse::kInfoFieldNumber;
const int RobotResponse::kPosFieldNumber;
const int RobotResponse::kMapFieldNumber;
const int RobotResponse::kTrailFieldNumber;
const int RobotResponse::kPointFieldNumber;
const int RobotResponse::kStatusFieldNumber;
const int RobotResponse::kMitionFieldNumber;
const int RobotResponse::kListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RobotResponse::RobotResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:RobotResponse)
}

void RobotResponse::InitAsDefaultInstance() {
  pos_ = const_cast< ::RobotPos*>(&::RobotPos::default_instance());
  map_ = const_cast< ::RobotMap*>(&::RobotMap::default_instance());
  trail_ = const_cast< ::RobotTrail*>(&::RobotTrail::default_instance());
  point_ = const_cast< ::MitionPoint*>(&::MitionPoint::default_instance());
  status_ = const_cast< ::RobotInfo*>(&::RobotInfo::default_instance());
  mition_ = const_cast< ::MitionStatus*>(&::MitionStatus::default_instance());
  list_ = const_cast< ::MapList*>(&::MapList::default_instance());
}

RobotResponse::RobotResponse(const RobotResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:RobotResponse)
}

void RobotResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  code_ = 0;
  info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pos_ = NULL;
  map_ = NULL;
  trail_ = NULL;
  point_ = NULL;
  status_ = NULL;
  mition_ = NULL;
  list_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RobotResponse::~RobotResponse() {
  // @@protoc_insertion_point(destructor:RobotResponse)
  SharedDtor();
}

void RobotResponse::SharedDtor() {
  info_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete pos_;
    delete map_;
    delete trail_;
    delete point_;
    delete status_;
    delete mition_;
    delete list_;
  }
}

void RobotResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RobotResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RobotResponse_descriptor_;
}

const RobotResponse& RobotResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_robot_2eproto();
  return *default_instance_;
}

RobotResponse* RobotResponse::default_instance_ = NULL;

RobotResponse* RobotResponse::New(::google::protobuf::Arena* arena) const {
  RobotResponse* n = new RobotResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RobotResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:RobotResponse)
  if (_has_bits_[0 / 32] & 255u) {
    code_ = 0;
    if (has_info()) {
      info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_pos()) {
      if (pos_ != NULL) pos_->::RobotPos::Clear();
    }
    if (has_map()) {
      if (map_ != NULL) map_->::RobotMap::Clear();
    }
    if (has_trail()) {
      if (trail_ != NULL) trail_->::RobotTrail::Clear();
    }
    if (has_point()) {
      if (point_ != NULL) point_->::MitionPoint::Clear();
    }
    if (has_status()) {
      if (status_ != NULL) status_->::RobotInfo::Clear();
    }
    if (has_mition()) {
      if (mition_ != NULL) mition_->::MitionStatus::Clear();
    }
  }
  if (has_list()) {
    if (list_ != NULL) list_->::MapList::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RobotResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:RobotResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &code_)));
          set_has_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_info;
        break;
      }

      // optional string info = 2;
      case 2: {
        if (tag == 18) {
         parse_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_info()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->info().data(), this->info().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "RobotResponse.info");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_pos;
        break;
      }

      // optional .RobotPos pos = 3;
      case 3: {
        if (tag == 26) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_map;
        break;
      }

      // optional .RobotMap map = 4;
      case 4: {
        if (tag == 34) {
         parse_map:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_map()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_trail;
        break;
      }

      // optional .RobotTrail trail = 5;
      case 5: {
        if (tag == 42) {
         parse_trail:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trail()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_point;
        break;
      }

      // optional .MitionPoint point = 6;
      case 6: {
        if (tag == 50) {
         parse_point:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_point()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_status;
        break;
      }

      // optional .RobotInfo status = 7;
      case 7: {
        if (tag == 58) {
         parse_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_mition;
        break;
      }

      // optional .MitionStatus mition = 8;
      case 8: {
        if (tag == 66) {
         parse_mition:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mition()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_list;
        break;
      }

      // optional .MapList list = 9;
      case 9: {
        if (tag == 74) {
         parse_list:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_list()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:RobotResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:RobotResponse)
  return false;
#undef DO_
}

void RobotResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:RobotResponse)
  // required int32 code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->code(), output);
  }

  // optional string info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->info().data(), this->info().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RobotResponse.info");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->info(), output);
  }

  // optional .RobotPos pos = 3;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->pos_, output);
  }

  // optional .RobotMap map = 4;
  if (has_map()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->map_, output);
  }

  // optional .RobotTrail trail = 5;
  if (has_trail()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->trail_, output);
  }

  // optional .MitionPoint point = 6;
  if (has_point()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->point_, output);
  }

  // optional .RobotInfo status = 7;
  if (has_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->status_, output);
  }

  // optional .MitionStatus mition = 8;
  if (has_mition()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->mition_, output);
  }

  // optional .MapList list = 9;
  if (has_list()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->list_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:RobotResponse)
}

::google::protobuf::uint8* RobotResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:RobotResponse)
  // required int32 code = 1;
  if (has_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->code(), target);
  }

  // optional string info = 2;
  if (has_info()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->info().data(), this->info().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "RobotResponse.info");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->info(), target);
  }

  // optional .RobotPos pos = 3;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->pos_, false, target);
  }

  // optional .RobotMap map = 4;
  if (has_map()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->map_, false, target);
  }

  // optional .RobotTrail trail = 5;
  if (has_trail()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->trail_, false, target);
  }

  // optional .MitionPoint point = 6;
  if (has_point()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->point_, false, target);
  }

  // optional .RobotInfo status = 7;
  if (has_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->status_, false, target);
  }

  // optional .MitionStatus mition = 8;
  if (has_mition()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->mition_, false, target);
  }

  // optional .MapList list = 9;
  if (has_list()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->list_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RobotResponse)
  return target;
}

int RobotResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:RobotResponse)
  int total_size = 0;

  // required int32 code = 1;
  if (has_code()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->code());
  }
  if (_has_bits_[1 / 32] & 254u) {
    // optional string info = 2;
    if (has_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->info());
    }

    // optional .RobotPos pos = 3;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->pos_);
    }

    // optional .RobotMap map = 4;
    if (has_map()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->map_);
    }

    // optional .RobotTrail trail = 5;
    if (has_trail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->trail_);
    }

    // optional .MitionPoint point = 6;
    if (has_point()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->point_);
    }

    // optional .RobotInfo status = 7;
    if (has_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->status_);
    }

    // optional .MitionStatus mition = 8;
    if (has_mition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->mition_);
    }

  }
  // optional .MapList list = 9;
  if (has_list()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->list_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RobotResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:RobotResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RobotResponse* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RobotResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:RobotResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:RobotResponse)
    MergeFrom(*source);
  }
}

void RobotResponse::MergeFrom(const RobotResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:RobotResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_info()) {
      set_has_info();
      info_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.info_);
    }
    if (from.has_pos()) {
      mutable_pos()->::RobotPos::MergeFrom(from.pos());
    }
    if (from.has_map()) {
      mutable_map()->::RobotMap::MergeFrom(from.map());
    }
    if (from.has_trail()) {
      mutable_trail()->::RobotTrail::MergeFrom(from.trail());
    }
    if (from.has_point()) {
      mutable_point()->::MitionPoint::MergeFrom(from.point());
    }
    if (from.has_status()) {
      mutable_status()->::RobotInfo::MergeFrom(from.status());
    }
    if (from.has_mition()) {
      mutable_mition()->::MitionStatus::MergeFrom(from.mition());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_list()) {
      mutable_list()->::MapList::MergeFrom(from.list());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RobotResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:RobotResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RobotResponse::CopyFrom(const RobotResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RobotResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_pos()) {
    if (!this->pos_->IsInitialized()) return false;
  }
  if (has_map()) {
    if (!this->map_->IsInitialized()) return false;
  }
  if (has_trail()) {
    if (!this->trail_->IsInitialized()) return false;
  }
  if (has_point()) {
    if (!this->point_->IsInitialized()) return false;
  }
  if (has_status()) {
    if (!this->status_->IsInitialized()) return false;
  }
  if (has_mition()) {
    if (!this->mition_->IsInitialized()) return false;
  }
  return true;
}

void RobotResponse::Swap(RobotResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RobotResponse::InternalSwap(RobotResponse* other) {
  std::swap(code_, other->code_);
  info_.Swap(&other->info_);
  std::swap(pos_, other->pos_);
  std::swap(map_, other->map_);
  std::swap(trail_, other->trail_);
  std::swap(point_, other->point_);
  std::swap(status_, other->status_);
  std::swap(mition_, other->mition_);
  std::swap(list_, other->list_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RobotResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RobotResponse_descriptor_;
  metadata.reflection = RobotResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RobotResponse

// required int32 code = 1;
bool RobotResponse::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RobotResponse::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
void RobotResponse::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
void RobotResponse::clear_code() {
  code_ = 0;
  clear_has_code();
}
 ::google::protobuf::int32 RobotResponse::code() const {
  // @@protoc_insertion_point(field_get:RobotResponse.code)
  return code_;
}
 void RobotResponse::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:RobotResponse.code)
}

// optional string info = 2;
bool RobotResponse::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RobotResponse::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
void RobotResponse::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
void RobotResponse::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info();
}
 const ::std::string& RobotResponse::info() const {
  // @@protoc_insertion_point(field_get:RobotResponse.info)
  return info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RobotResponse::set_info(const ::std::string& value) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RobotResponse.info)
}
 void RobotResponse::set_info(const char* value) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RobotResponse.info)
}
 void RobotResponse::set_info(const char* value, size_t size) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RobotResponse.info)
}
 ::std::string* RobotResponse::mutable_info() {
  set_has_info();
  // @@protoc_insertion_point(field_mutable:RobotResponse.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RobotResponse::release_info() {
  // @@protoc_insertion_point(field_release:RobotResponse.info)
  clear_has_info();
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RobotResponse::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    set_has_info();
  } else {
    clear_has_info();
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.info)
}

// optional .RobotPos pos = 3;
bool RobotResponse::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RobotResponse::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
void RobotResponse::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
void RobotResponse::clear_pos() {
  if (pos_ != NULL) pos_->::RobotPos::Clear();
  clear_has_pos();
}
const ::RobotPos& RobotResponse::pos() const {
  // @@protoc_insertion_point(field_get:RobotResponse.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
::RobotPos* RobotResponse::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::RobotPos;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.pos)
  return pos_;
}
::RobotPos* RobotResponse::release_pos() {
  // @@protoc_insertion_point(field_release:RobotResponse.pos)
  clear_has_pos();
  ::RobotPos* temp = pos_;
  pos_ = NULL;
  return temp;
}
void RobotResponse::set_allocated_pos(::RobotPos* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.pos)
}

// optional .RobotMap map = 4;
bool RobotResponse::has_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void RobotResponse::set_has_map() {
  _has_bits_[0] |= 0x00000008u;
}
void RobotResponse::clear_has_map() {
  _has_bits_[0] &= ~0x00000008u;
}
void RobotResponse::clear_map() {
  if (map_ != NULL) map_->::RobotMap::Clear();
  clear_has_map();
}
const ::RobotMap& RobotResponse::map() const {
  // @@protoc_insertion_point(field_get:RobotResponse.map)
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
::RobotMap* RobotResponse::mutable_map() {
  set_has_map();
  if (map_ == NULL) {
    map_ = new ::RobotMap;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.map)
  return map_;
}
::RobotMap* RobotResponse::release_map() {
  // @@protoc_insertion_point(field_release:RobotResponse.map)
  clear_has_map();
  ::RobotMap* temp = map_;
  map_ = NULL;
  return temp;
}
void RobotResponse::set_allocated_map(::RobotMap* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.map)
}

// optional .RobotTrail trail = 5;
bool RobotResponse::has_trail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void RobotResponse::set_has_trail() {
  _has_bits_[0] |= 0x00000010u;
}
void RobotResponse::clear_has_trail() {
  _has_bits_[0] &= ~0x00000010u;
}
void RobotResponse::clear_trail() {
  if (trail_ != NULL) trail_->::RobotTrail::Clear();
  clear_has_trail();
}
const ::RobotTrail& RobotResponse::trail() const {
  // @@protoc_insertion_point(field_get:RobotResponse.trail)
  return trail_ != NULL ? *trail_ : *default_instance_->trail_;
}
::RobotTrail* RobotResponse::mutable_trail() {
  set_has_trail();
  if (trail_ == NULL) {
    trail_ = new ::RobotTrail;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.trail)
  return trail_;
}
::RobotTrail* RobotResponse::release_trail() {
  // @@protoc_insertion_point(field_release:RobotResponse.trail)
  clear_has_trail();
  ::RobotTrail* temp = trail_;
  trail_ = NULL;
  return temp;
}
void RobotResponse::set_allocated_trail(::RobotTrail* trail) {
  delete trail_;
  trail_ = trail;
  if (trail) {
    set_has_trail();
  } else {
    clear_has_trail();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.trail)
}

// optional .MitionPoint point = 6;
bool RobotResponse::has_point() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void RobotResponse::set_has_point() {
  _has_bits_[0] |= 0x00000020u;
}
void RobotResponse::clear_has_point() {
  _has_bits_[0] &= ~0x00000020u;
}
void RobotResponse::clear_point() {
  if (point_ != NULL) point_->::MitionPoint::Clear();
  clear_has_point();
}
const ::MitionPoint& RobotResponse::point() const {
  // @@protoc_insertion_point(field_get:RobotResponse.point)
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
::MitionPoint* RobotResponse::mutable_point() {
  set_has_point();
  if (point_ == NULL) {
    point_ = new ::MitionPoint;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.point)
  return point_;
}
::MitionPoint* RobotResponse::release_point() {
  // @@protoc_insertion_point(field_release:RobotResponse.point)
  clear_has_point();
  ::MitionPoint* temp = point_;
  point_ = NULL;
  return temp;
}
void RobotResponse::set_allocated_point(::MitionPoint* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.point)
}

// optional .RobotInfo status = 7;
bool RobotResponse::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void RobotResponse::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
void RobotResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
void RobotResponse::clear_status() {
  if (status_ != NULL) status_->::RobotInfo::Clear();
  clear_has_status();
}
const ::RobotInfo& RobotResponse::status() const {
  // @@protoc_insertion_point(field_get:RobotResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
::RobotInfo* RobotResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::RobotInfo;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.status)
  return status_;
}
::RobotInfo* RobotResponse::release_status() {
  // @@protoc_insertion_point(field_release:RobotResponse.status)
  clear_has_status();
  ::RobotInfo* temp = status_;
  status_ = NULL;
  return temp;
}
void RobotResponse::set_allocated_status(::RobotInfo* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.status)
}

// optional .MitionStatus mition = 8;
bool RobotResponse::has_mition() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void RobotResponse::set_has_mition() {
  _has_bits_[0] |= 0x00000080u;
}
void RobotResponse::clear_has_mition() {
  _has_bits_[0] &= ~0x00000080u;
}
void RobotResponse::clear_mition() {
  if (mition_ != NULL) mition_->::MitionStatus::Clear();
  clear_has_mition();
}
const ::MitionStatus& RobotResponse::mition() const {
  // @@protoc_insertion_point(field_get:RobotResponse.mition)
  return mition_ != NULL ? *mition_ : *default_instance_->mition_;
}
::MitionStatus* RobotResponse::mutable_mition() {
  set_has_mition();
  if (mition_ == NULL) {
    mition_ = new ::MitionStatus;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.mition)
  return mition_;
}
::MitionStatus* RobotResponse::release_mition() {
  // @@protoc_insertion_point(field_release:RobotResponse.mition)
  clear_has_mition();
  ::MitionStatus* temp = mition_;
  mition_ = NULL;
  return temp;
}
void RobotResponse::set_allocated_mition(::MitionStatus* mition) {
  delete mition_;
  mition_ = mition;
  if (mition) {
    set_has_mition();
  } else {
    clear_has_mition();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.mition)
}

// optional .MapList list = 9;
bool RobotResponse::has_list() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void RobotResponse::set_has_list() {
  _has_bits_[0] |= 0x00000100u;
}
void RobotResponse::clear_has_list() {
  _has_bits_[0] &= ~0x00000100u;
}
void RobotResponse::clear_list() {
  if (list_ != NULL) list_->::MapList::Clear();
  clear_has_list();
}
const ::MapList& RobotResponse::list() const {
  // @@protoc_insertion_point(field_get:RobotResponse.list)
  return list_ != NULL ? *list_ : *default_instance_->list_;
}
::MapList* RobotResponse::mutable_list() {
  set_has_list();
  if (list_ == NULL) {
    list_ = new ::MapList;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.list)
  return list_;
}
::MapList* RobotResponse::release_list() {
  // @@protoc_insertion_point(field_release:RobotResponse.list)
  clear_has_list();
  ::MapList* temp = list_;
  list_ = NULL;
  return temp;
}
void RobotResponse::set_allocated_list(::MapList* list) {
  delete list_;
  list_ = list;
  if (list) {
    set_has_list();
  } else {
    clear_has_list();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.list)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
