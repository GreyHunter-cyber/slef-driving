// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot.proto

#ifndef PROTOBUF_robot_2eproto__INCLUDED
#define PROTOBUF_robot_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_robot_2eproto();
void protobuf_AssignDesc_robot_2eproto();
void protobuf_ShutdownFile_robot_2eproto();

class MapList;
class MitionPoint;
class MitionStatus;
class OriginPoint;
class RobotDrive;
class RobotInfo;
class RobotMap;
class RobotPos;
class RobotRequest;
class RobotResponse;
class RobotTrail;

enum RobotDrive_Mode {
  RobotDrive_Mode_FREE = 0,
  RobotDrive_Mode_PAUSE = 1,
  RobotDrive_Mode_STOP = 2,
  RobotDrive_Mode_DRIVE = 3
};
bool RobotDrive_Mode_IsValid(int value);
const RobotDrive_Mode RobotDrive_Mode_Mode_MIN = RobotDrive_Mode_FREE;
const RobotDrive_Mode RobotDrive_Mode_Mode_MAX = RobotDrive_Mode_DRIVE;
const int RobotDrive_Mode_Mode_ARRAYSIZE = RobotDrive_Mode_Mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotDrive_Mode_descriptor();
inline const ::std::string& RobotDrive_Mode_Name(RobotDrive_Mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotDrive_Mode_descriptor(), value);
}
inline bool RobotDrive_Mode_Parse(
    const ::std::string& name, RobotDrive_Mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotDrive_Mode>(
    RobotDrive_Mode_descriptor(), name, value);
}
enum RobotRequest_Wants {
  RobotRequest_Wants_NONE = 0,
  RobotRequest_Wants_POS = 1,
  RobotRequest_Wants_MAP = 2,
  RobotRequest_Wants_TRAIL = 4
};
bool RobotRequest_Wants_IsValid(int value);
const RobotRequest_Wants RobotRequest_Wants_Wants_MIN = RobotRequest_Wants_NONE;
const RobotRequest_Wants RobotRequest_Wants_Wants_MAX = RobotRequest_Wants_TRAIL;
const int RobotRequest_Wants_Wants_ARRAYSIZE = RobotRequest_Wants_Wants_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotRequest_Wants_descriptor();
inline const ::std::string& RobotRequest_Wants_Name(RobotRequest_Wants value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotRequest_Wants_descriptor(), value);
}
inline bool RobotRequest_Wants_Parse(
    const ::std::string& name, RobotRequest_Wants* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotRequest_Wants>(
    RobotRequest_Wants_descriptor(), name, value);
}
enum RobotRequest_Action {
  RobotRequest_Action_NOOP = 0,
  RobotRequest_Action_POINT_APPLY = 1,
  RobotRequest_Action_NAVIGATION = 2,
  RobotRequest_Action_INIT_ORIGIN = 3,
  RobotRequest_Action_CREAT_MAP = 4,
  RobotRequest_Action_FINISH_MAP = 5,
  RobotRequest_Action_UPLOAD_MAP = 6,
  RobotRequest_Action_DOWNLOAD_MAP = 7,
  RobotRequest_Action_CHOICE_MAP = 8
};
bool RobotRequest_Action_IsValid(int value);
const RobotRequest_Action RobotRequest_Action_Action_MIN = RobotRequest_Action_NOOP;
const RobotRequest_Action RobotRequest_Action_Action_MAX = RobotRequest_Action_CHOICE_MAP;
const int RobotRequest_Action_Action_ARRAYSIZE = RobotRequest_Action_Action_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotRequest_Action_descriptor();
inline const ::std::string& RobotRequest_Action_Name(RobotRequest_Action value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotRequest_Action_descriptor(), value);
}
inline bool RobotRequest_Action_Parse(
    const ::std::string& name, RobotRequest_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotRequest_Action>(
    RobotRequest_Action_descriptor(), name, value);
}
enum RobotMap_Grid {
  RobotMap_Grid_UNKOWN = 0,
  RobotMap_Grid_FREE = 1,
  RobotMap_Grid_OCCUPIED = 2,
  RobotMap_Grid_FEATURE = 3
};
bool RobotMap_Grid_IsValid(int value);
const RobotMap_Grid RobotMap_Grid_Grid_MIN = RobotMap_Grid_UNKOWN;
const RobotMap_Grid RobotMap_Grid_Grid_MAX = RobotMap_Grid_FEATURE;
const int RobotMap_Grid_Grid_ARRAYSIZE = RobotMap_Grid_Grid_MAX + 1;

const ::google::protobuf::EnumDescriptor* RobotMap_Grid_descriptor();
inline const ::std::string& RobotMap_Grid_Name(RobotMap_Grid value) {
  return ::google::protobuf::internal::NameOfEnum(
    RobotMap_Grid_descriptor(), value);
}
inline bool RobotMap_Grid_Parse(
    const ::std::string& name, RobotMap_Grid* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RobotMap_Grid>(
    RobotMap_Grid_descriptor(), name, value);
}
// ===================================================================

class RobotDrive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RobotDrive) */ {
 public:
  RobotDrive();
  virtual ~RobotDrive();

  RobotDrive(const RobotDrive& from);

  inline RobotDrive& operator=(const RobotDrive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotDrive& default_instance();

  void Swap(RobotDrive* other);

  // implements Message ----------------------------------------------

  inline RobotDrive* New() const { return New(NULL); }

  RobotDrive* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotDrive& from);
  void MergeFrom(const RobotDrive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RobotDrive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RobotDrive_Mode Mode;
  static const Mode FREE =
    RobotDrive_Mode_FREE;
  static const Mode PAUSE =
    RobotDrive_Mode_PAUSE;
  static const Mode STOP =
    RobotDrive_Mode_STOP;
  static const Mode DRIVE =
    RobotDrive_Mode_DRIVE;
  static inline bool Mode_IsValid(int value) {
    return RobotDrive_Mode_IsValid(value);
  }
  static const Mode Mode_MIN =
    RobotDrive_Mode_Mode_MIN;
  static const Mode Mode_MAX =
    RobotDrive_Mode_Mode_MAX;
  static const int Mode_ARRAYSIZE =
    RobotDrive_Mode_Mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Mode_descriptor() {
    return RobotDrive_Mode_descriptor();
  }
  static inline const ::std::string& Mode_Name(Mode value) {
    return RobotDrive_Mode_Name(value);
  }
  static inline bool Mode_Parse(const ::std::string& name,
      Mode* value) {
    return RobotDrive_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .RobotDrive.Mode mode = 1;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 1;
  ::RobotDrive_Mode mode() const;
  void set_mode(::RobotDrive_Mode value);

  // optional float speed = 2;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 2;
  float speed() const;
  void set_speed(float value);

  // optional float angle = 3;
  bool has_angle() const;
  void clear_angle();
  static const int kAngleFieldNumber = 3;
  float angle() const;
  void set_angle(float value);

  // @@protoc_insertion_point(class_scope:RobotDrive)
 private:
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int mode_;
  float speed_;
  float angle_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static RobotDrive* default_instance_;
};
// -------------------------------------------------------------------

class MitionPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MitionPoint) */ {
 public:
  MitionPoint();
  virtual ~MitionPoint();

  MitionPoint(const MitionPoint& from);

  inline MitionPoint& operator=(const MitionPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MitionPoint& default_instance();

  void Swap(MitionPoint* other);

  // implements Message ----------------------------------------------

  inline MitionPoint* New() const { return New(NULL); }

  MitionPoint* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MitionPoint& from);
  void MergeFrom(const MitionPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MitionPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required int32 attribute = 3;
  bool has_attribute() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 3;
  ::google::protobuf::int32 attribute() const;
  void set_attribute(::google::protobuf::int32 value);

  // required float m_speed = 4;
  bool has_m_speed() const;
  void clear_m_speed();
  static const int kMSpeedFieldNumber = 4;
  float m_speed() const;
  void set_m_speed(float value);

  // @@protoc_insertion_point(class_scope:MitionPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_attribute();
  inline void clear_has_attribute();
  inline void set_has_m_speed();
  inline void clear_has_m_speed();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  ::google::protobuf::int32 attribute_;
  float m_speed_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static MitionPoint* default_instance_;
};
// -------------------------------------------------------------------

class OriginPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OriginPoint) */ {
 public:
  OriginPoint();
  virtual ~OriginPoint();

  OriginPoint(const OriginPoint& from);

  inline OriginPoint& operator=(const OriginPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OriginPoint& default_instance();

  void Swap(OriginPoint* other);

  // implements Message ----------------------------------------------

  inline OriginPoint* New() const { return New(NULL); }

  OriginPoint* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OriginPoint& from);
  void MergeFrom(const OriginPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OriginPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:OriginPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static OriginPoint* default_instance_;
};
// -------------------------------------------------------------------

class MapList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MapList) */ {
 public:
  MapList();
  virtual ~MapList();

  MapList(const MapList& from);

  inline MapList& operator=(const MapList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapList& default_instance();

  void Swap(MapList* other);

  // implements Message ----------------------------------------------

  inline MapList* New() const { return New(NULL); }

  MapList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapList& from);
  void MergeFrom(const MapList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string mapname = 1;
  int mapname_size() const;
  void clear_mapname();
  static const int kMapnameFieldNumber = 1;
  const ::std::string& mapname(int index) const;
  ::std::string* mutable_mapname(int index);
  void set_mapname(int index, const ::std::string& value);
  void set_mapname(int index, const char* value);
  void set_mapname(int index, const char* value, size_t size);
  ::std::string* add_mapname();
  void add_mapname(const ::std::string& value);
  void add_mapname(const char* value);
  void add_mapname(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& mapname() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_mapname();

  // @@protoc_insertion_point(class_scope:MapList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> mapname_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static MapList* default_instance_;
};
// -------------------------------------------------------------------

class RobotRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RobotRequest) */ {
 public:
  RobotRequest();
  virtual ~RobotRequest();

  RobotRequest(const RobotRequest& from);

  inline RobotRequest& operator=(const RobotRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotRequest& default_instance();

  void Swap(RobotRequest* other);

  // implements Message ----------------------------------------------

  inline RobotRequest* New() const { return New(NULL); }

  RobotRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotRequest& from);
  void MergeFrom(const RobotRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RobotRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RobotRequest_Wants Wants;
  static const Wants NONE =
    RobotRequest_Wants_NONE;
  static const Wants POS =
    RobotRequest_Wants_POS;
  static const Wants MAP =
    RobotRequest_Wants_MAP;
  static const Wants TRAIL =
    RobotRequest_Wants_TRAIL;
  static inline bool Wants_IsValid(int value) {
    return RobotRequest_Wants_IsValid(value);
  }
  static const Wants Wants_MIN =
    RobotRequest_Wants_Wants_MIN;
  static const Wants Wants_MAX =
    RobotRequest_Wants_Wants_MAX;
  static const int Wants_ARRAYSIZE =
    RobotRequest_Wants_Wants_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Wants_descriptor() {
    return RobotRequest_Wants_descriptor();
  }
  static inline const ::std::string& Wants_Name(Wants value) {
    return RobotRequest_Wants_Name(value);
  }
  static inline bool Wants_Parse(const ::std::string& name,
      Wants* value) {
    return RobotRequest_Wants_Parse(name, value);
  }

  typedef RobotRequest_Action Action;
  static const Action NOOP =
    RobotRequest_Action_NOOP;
  static const Action POINT_APPLY =
    RobotRequest_Action_POINT_APPLY;
  static const Action NAVIGATION =
    RobotRequest_Action_NAVIGATION;
  static const Action INIT_ORIGIN =
    RobotRequest_Action_INIT_ORIGIN;
  static const Action CREAT_MAP =
    RobotRequest_Action_CREAT_MAP;
  static const Action FINISH_MAP =
    RobotRequest_Action_FINISH_MAP;
  static const Action UPLOAD_MAP =
    RobotRequest_Action_UPLOAD_MAP;
  static const Action DOWNLOAD_MAP =
    RobotRequest_Action_DOWNLOAD_MAP;
  static const Action CHOICE_MAP =
    RobotRequest_Action_CHOICE_MAP;
  static inline bool Action_IsValid(int value) {
    return RobotRequest_Action_IsValid(value);
  }
  static const Action Action_MIN =
    RobotRequest_Action_Action_MIN;
  static const Action Action_MAX =
    RobotRequest_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    RobotRequest_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Action_descriptor() {
    return RobotRequest_Action_descriptor();
  }
  static inline const ::std::string& Action_Name(Action value) {
    return RobotRequest_Action_Name(value);
  }
  static inline bool Action_Parse(const ::std::string& name,
      Action* value) {
    return RobotRequest_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes token = 1;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // required int32 wants = 2;
  bool has_wants() const;
  void clear_wants();
  static const int kWantsFieldNumber = 2;
  ::google::protobuf::int32 wants() const;
  void set_wants(::google::protobuf::int32 value);

  // required int32 action = 3;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 3;
  ::google::protobuf::int32 action() const;
  void set_action(::google::protobuf::int32 value);

  // optional .RobotDrive drive = 4;
  bool has_drive() const;
  void clear_drive();
  static const int kDriveFieldNumber = 4;
  const ::RobotDrive& drive() const;
  ::RobotDrive* mutable_drive();
  ::RobotDrive* release_drive();
  void set_allocated_drive(::RobotDrive* drive);

  // repeated .MitionPoint point = 5;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 5;
  const ::MitionPoint& point(int index) const;
  ::MitionPoint* mutable_point(int index);
  ::MitionPoint* add_point();
  ::google::protobuf::RepeatedPtrField< ::MitionPoint >*
      mutable_point();
  const ::google::protobuf::RepeatedPtrField< ::MitionPoint >&
      point() const;

  // optional .OriginPoint origin = 6;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 6;
  const ::OriginPoint& origin() const;
  ::OriginPoint* mutable_origin();
  ::OriginPoint* release_origin();
  void set_allocated_origin(::OriginPoint* origin);

  // optional int32 confirm = 7;
  bool has_confirm() const;
  void clear_confirm();
  static const int kConfirmFieldNumber = 7;
  ::google::protobuf::int32 confirm() const;
  void set_confirm(::google::protobuf::int32 value);

  // optional string mapname = 8;
  bool has_mapname() const;
  void clear_mapname();
  static const int kMapnameFieldNumber = 8;
  const ::std::string& mapname() const;
  void set_mapname(const ::std::string& value);
  void set_mapname(const char* value);
  void set_mapname(const char* value, size_t size);
  ::std::string* mutable_mapname();
  ::std::string* release_mapname();
  void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:RobotRequest)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_wants();
  inline void clear_has_wants();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_drive();
  inline void clear_has_drive();
  inline void set_has_origin();
  inline void clear_has_origin();
  inline void set_has_confirm();
  inline void clear_has_confirm();
  inline void set_has_mapname();
  inline void clear_has_mapname();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::int32 wants_;
  ::google::protobuf::int32 action_;
  ::RobotDrive* drive_;
  ::google::protobuf::RepeatedPtrField< ::MitionPoint > point_;
  ::OriginPoint* origin_;
  ::google::protobuf::internal::ArenaStringPtr mapname_;
  ::google::protobuf::int32 confirm_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static RobotRequest* default_instance_;
};
// -------------------------------------------------------------------

class RobotMap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RobotMap) */ {
 public:
  RobotMap();
  virtual ~RobotMap();

  RobotMap(const RobotMap& from);

  inline RobotMap& operator=(const RobotMap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotMap& default_instance();

  void Swap(RobotMap* other);

  // implements Message ----------------------------------------------

  inline RobotMap* New() const { return New(NULL); }

  RobotMap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotMap& from);
  void MergeFrom(const RobotMap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RobotMap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RobotMap_Grid Grid;
  static const Grid UNKOWN =
    RobotMap_Grid_UNKOWN;
  static const Grid FREE =
    RobotMap_Grid_FREE;
  static const Grid OCCUPIED =
    RobotMap_Grid_OCCUPIED;
  static const Grid FEATURE =
    RobotMap_Grid_FEATURE;
  static inline bool Grid_IsValid(int value) {
    return RobotMap_Grid_IsValid(value);
  }
  static const Grid Grid_MIN =
    RobotMap_Grid_Grid_MIN;
  static const Grid Grid_MAX =
    RobotMap_Grid_Grid_MAX;
  static const int Grid_ARRAYSIZE =
    RobotMap_Grid_Grid_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Grid_descriptor() {
    return RobotMap_Grid_descriptor();
  }
  static inline const ::std::string& Grid_Name(Grid value) {
    return RobotMap_Grid_Name(value);
  }
  static inline bool Grid_Parse(const ::std::string& name,
      Grid* value) {
    return RobotMap_Grid_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required double origin_x = 1;
  bool has_origin_x() const;
  void clear_origin_x();
  static const int kOriginXFieldNumber = 1;
  double origin_x() const;
  void set_origin_x(double value);

  // required double origin_y = 2;
  bool has_origin_y() const;
  void clear_origin_y();
  static const int kOriginYFieldNumber = 2;
  double origin_y() const;
  void set_origin_y(double value);

  // required int32 size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // required int32 grids_x = 4;
  bool has_grids_x() const;
  void clear_grids_x();
  static const int kGridsXFieldNumber = 4;
  ::google::protobuf::int32 grids_x() const;
  void set_grids_x(::google::protobuf::int32 value);

  // required int32 grids_y = 5;
  bool has_grids_y() const;
  void clear_grids_y();
  static const int kGridsYFieldNumber = 5;
  ::google::protobuf::int32 grids_y() const;
  void set_grids_y(::google::protobuf::int32 value);

  // required bytes zgrids = 6;
  bool has_zgrids() const;
  void clear_zgrids();
  static const int kZgridsFieldNumber = 6;
  const ::std::string& zgrids() const;
  void set_zgrids(const ::std::string& value);
  void set_zgrids(const char* value);
  void set_zgrids(const void* value, size_t size);
  ::std::string* mutable_zgrids();
  ::std::string* release_zgrids();
  void set_allocated_zgrids(::std::string* zgrids);

  // @@protoc_insertion_point(class_scope:RobotMap)
 private:
  inline void set_has_origin_x();
  inline void clear_has_origin_x();
  inline void set_has_origin_y();
  inline void clear_has_origin_y();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_grids_x();
  inline void clear_has_grids_x();
  inline void set_has_grids_y();
  inline void clear_has_grids_y();
  inline void set_has_zgrids();
  inline void clear_has_zgrids();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double origin_x_;
  double origin_y_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 grids_x_;
  ::google::protobuf::internal::ArenaStringPtr zgrids_;
  ::google::protobuf::int32 grids_y_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static RobotMap* default_instance_;
};
// -------------------------------------------------------------------

class RobotPos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RobotPos) */ {
 public:
  RobotPos();
  virtual ~RobotPos();

  RobotPos(const RobotPos& from);

  inline RobotPos& operator=(const RobotPos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotPos& default_instance();

  void Swap(RobotPos* other);

  // implements Message ----------------------------------------------

  inline RobotPos* New() const { return New(NULL); }

  RobotPos* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotPos& from);
  void MergeFrom(const RobotPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RobotPos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float offset_x = 1;
  bool has_offset_x() const;
  void clear_offset_x();
  static const int kOffsetXFieldNumber = 1;
  float offset_x() const;
  void set_offset_x(float value);

  // required float offset_y = 2;
  bool has_offset_y() const;
  void clear_offset_y();
  static const int kOffsetYFieldNumber = 2;
  float offset_y() const;
  void set_offset_y(float value);

  // optional float angle = 3;
  bool has_angle() const;
  void clear_angle();
  static const int kAngleFieldNumber = 3;
  float angle() const;
  void set_angle(float value);

  // @@protoc_insertion_point(class_scope:RobotPos)
 private:
  inline void set_has_offset_x();
  inline void clear_has_offset_x();
  inline void set_has_offset_y();
  inline void clear_has_offset_y();
  inline void set_has_angle();
  inline void clear_has_angle();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float offset_x_;
  float offset_y_;
  float angle_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static RobotPos* default_instance_;
};
// -------------------------------------------------------------------

class RobotTrail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RobotTrail) */ {
 public:
  RobotTrail();
  virtual ~RobotTrail();

  RobotTrail(const RobotTrail& from);

  inline RobotTrail& operator=(const RobotTrail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotTrail& default_instance();

  void Swap(RobotTrail* other);

  // implements Message ----------------------------------------------

  inline RobotTrail* New() const { return New(NULL); }

  RobotTrail* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotTrail& from);
  void MergeFrom(const RobotTrail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RobotTrail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .RobotPos trail = 1;
  int trail_size() const;
  void clear_trail();
  static const int kTrailFieldNumber = 1;
  const ::RobotPos& trail(int index) const;
  ::RobotPos* mutable_trail(int index);
  ::RobotPos* add_trail();
  ::google::protobuf::RepeatedPtrField< ::RobotPos >*
      mutable_trail();
  const ::google::protobuf::RepeatedPtrField< ::RobotPos >&
      trail() const;

  // @@protoc_insertion_point(class_scope:RobotTrail)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::RobotPos > trail_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static RobotTrail* default_instance_;
};
// -------------------------------------------------------------------

class RobotInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RobotInfo) */ {
 public:
  RobotInfo();
  virtual ~RobotInfo();

  RobotInfo(const RobotInfo& from);

  inline RobotInfo& operator=(const RobotInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotInfo& default_instance();

  void Swap(RobotInfo* other);

  // implements Message ----------------------------------------------

  inline RobotInfo* New() const { return New(NULL); }

  RobotInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotInfo& from);
  void MergeFrom(const RobotInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RobotInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float speed = 1;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 1;
  float speed() const;
  void set_speed(float value);

  // required float voltage = 2;
  bool has_voltage() const;
  void clear_voltage();
  static const int kVoltageFieldNumber = 2;
  float voltage() const;
  void set_voltage(float value);

  // required float cur_x = 3;
  bool has_cur_x() const;
  void clear_cur_x();
  static const int kCurXFieldNumber = 3;
  float cur_x() const;
  void set_cur_x(float value);

  // required float cur_y = 4;
  bool has_cur_y() const;
  void clear_cur_y();
  static const int kCurYFieldNumber = 4;
  float cur_y() const;
  void set_cur_y(float value);

  // required float cur_yaw = 5;
  bool has_cur_yaw() const;
  void clear_cur_yaw();
  static const int kCurYawFieldNumber = 5;
  float cur_yaw() const;
  void set_cur_yaw(float value);

  // @@protoc_insertion_point(class_scope:RobotInfo)
 private:
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_voltage();
  inline void clear_has_voltage();
  inline void set_has_cur_x();
  inline void clear_has_cur_x();
  inline void set_has_cur_y();
  inline void clear_has_cur_y();
  inline void set_has_cur_yaw();
  inline void clear_has_cur_yaw();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float speed_;
  float voltage_;
  float cur_x_;
  float cur_y_;
  float cur_yaw_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static RobotInfo* default_instance_;
};
// -------------------------------------------------------------------

class MitionStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MitionStatus) */ {
 public:
  MitionStatus();
  virtual ~MitionStatus();

  MitionStatus(const MitionStatus& from);

  inline MitionStatus& operator=(const MitionStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MitionStatus& default_instance();

  void Swap(MitionStatus* other);

  // implements Message ----------------------------------------------

  inline MitionStatus* New() const { return New(NULL); }

  MitionStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MitionStatus& from);
  void MergeFrom(const MitionStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MitionStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mition_number = 1;
  bool has_mition_number() const;
  void clear_mition_number();
  static const int kMitionNumberFieldNumber = 1;
  ::google::protobuf::int32 mition_number() const;
  void set_mition_number(::google::protobuf::int32 value);

  // required bool mition_finish = 2;
  bool has_mition_finish() const;
  void clear_mition_finish();
  static const int kMitionFinishFieldNumber = 2;
  bool mition_finish() const;
  void set_mition_finish(bool value);

  // @@protoc_insertion_point(class_scope:MitionStatus)
 private:
  inline void set_has_mition_number();
  inline void clear_has_mition_number();
  inline void set_has_mition_finish();
  inline void clear_has_mition_finish();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 mition_number_;
  bool mition_finish_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static MitionStatus* default_instance_;
};
// -------------------------------------------------------------------

class RobotResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RobotResponse) */ {
 public:
  RobotResponse();
  virtual ~RobotResponse();

  RobotResponse(const RobotResponse& from);

  inline RobotResponse& operator=(const RobotResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotResponse& default_instance();

  void Swap(RobotResponse* other);

  // implements Message ----------------------------------------------

  inline RobotResponse* New() const { return New(NULL); }

  RobotResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotResponse& from);
  void MergeFrom(const RobotResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RobotResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // optional string info = 2;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // optional .RobotPos pos = 3;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 3;
  const ::RobotPos& pos() const;
  ::RobotPos* mutable_pos();
  ::RobotPos* release_pos();
  void set_allocated_pos(::RobotPos* pos);

  // optional .RobotMap map = 4;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 4;
  const ::RobotMap& map() const;
  ::RobotMap* mutable_map();
  ::RobotMap* release_map();
  void set_allocated_map(::RobotMap* map);

  // optional .RobotTrail trail = 5;
  bool has_trail() const;
  void clear_trail();
  static const int kTrailFieldNumber = 5;
  const ::RobotTrail& trail() const;
  ::RobotTrail* mutable_trail();
  ::RobotTrail* release_trail();
  void set_allocated_trail(::RobotTrail* trail);

  // optional .MitionPoint point = 6;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 6;
  const ::MitionPoint& point() const;
  ::MitionPoint* mutable_point();
  ::MitionPoint* release_point();
  void set_allocated_point(::MitionPoint* point);

  // optional .RobotInfo status = 7;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 7;
  const ::RobotInfo& status() const;
  ::RobotInfo* mutable_status();
  ::RobotInfo* release_status();
  void set_allocated_status(::RobotInfo* status);

  // optional .MitionStatus mition = 8;
  bool has_mition() const;
  void clear_mition();
  static const int kMitionFieldNumber = 8;
  const ::MitionStatus& mition() const;
  ::MitionStatus* mutable_mition();
  ::MitionStatus* release_mition();
  void set_allocated_mition(::MitionStatus* mition);

  // optional .MapList list = 9;
  bool has_list() const;
  void clear_list();
  static const int kListFieldNumber = 9;
  const ::MapList& list() const;
  ::MapList* mutable_list();
  ::MapList* release_list();
  void set_allocated_list(::MapList* list);

  // @@protoc_insertion_point(class_scope:RobotResponse)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_map();
  inline void clear_has_map();
  inline void set_has_trail();
  inline void clear_has_trail();
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_mition();
  inline void clear_has_mition();
  inline void set_has_list();
  inline void clear_has_list();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::RobotPos* pos_;
  ::RobotMap* map_;
  ::RobotTrail* trail_;
  ::MitionPoint* point_;
  ::RobotInfo* status_;
  ::MitionStatus* mition_;
  ::MapList* list_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_robot_2eproto();
  friend void protobuf_AssignDesc_robot_2eproto();
  friend void protobuf_ShutdownFile_robot_2eproto();

  void InitAsDefaultInstance();
  static RobotResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RobotDrive

// required .RobotDrive.Mode mode = 1;
inline bool RobotDrive::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotDrive::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotDrive::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotDrive::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::RobotDrive_Mode RobotDrive::mode() const {
  // @@protoc_insertion_point(field_get:RobotDrive.mode)
  return static_cast< ::RobotDrive_Mode >(mode_);
}
inline void RobotDrive::set_mode(::RobotDrive_Mode value) {
  assert(::RobotDrive_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:RobotDrive.mode)
}

// optional float speed = 2;
inline bool RobotDrive::has_speed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotDrive::set_has_speed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotDrive::clear_has_speed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotDrive::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float RobotDrive::speed() const {
  // @@protoc_insertion_point(field_get:RobotDrive.speed)
  return speed_;
}
inline void RobotDrive::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:RobotDrive.speed)
}

// optional float angle = 3;
inline bool RobotDrive::has_angle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotDrive::set_has_angle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotDrive::clear_has_angle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotDrive::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float RobotDrive::angle() const {
  // @@protoc_insertion_point(field_get:RobotDrive.angle)
  return angle_;
}
inline void RobotDrive::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:RobotDrive.angle)
}

// -------------------------------------------------------------------

// MitionPoint

// required float x = 1;
inline bool MitionPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MitionPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MitionPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MitionPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float MitionPoint::x() const {
  // @@protoc_insertion_point(field_get:MitionPoint.x)
  return x_;
}
inline void MitionPoint::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:MitionPoint.x)
}

// required float y = 2;
inline bool MitionPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MitionPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MitionPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MitionPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float MitionPoint::y() const {
  // @@protoc_insertion_point(field_get:MitionPoint.y)
  return y_;
}
inline void MitionPoint::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:MitionPoint.y)
}

// required int32 attribute = 3;
inline bool MitionPoint::has_attribute() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MitionPoint::set_has_attribute() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MitionPoint::clear_has_attribute() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MitionPoint::clear_attribute() {
  attribute_ = 0;
  clear_has_attribute();
}
inline ::google::protobuf::int32 MitionPoint::attribute() const {
  // @@protoc_insertion_point(field_get:MitionPoint.attribute)
  return attribute_;
}
inline void MitionPoint::set_attribute(::google::protobuf::int32 value) {
  set_has_attribute();
  attribute_ = value;
  // @@protoc_insertion_point(field_set:MitionPoint.attribute)
}

// required float m_speed = 4;
inline bool MitionPoint::has_m_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MitionPoint::set_has_m_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MitionPoint::clear_has_m_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MitionPoint::clear_m_speed() {
  m_speed_ = 0;
  clear_has_m_speed();
}
inline float MitionPoint::m_speed() const {
  // @@protoc_insertion_point(field_get:MitionPoint.m_speed)
  return m_speed_;
}
inline void MitionPoint::set_m_speed(float value) {
  set_has_m_speed();
  m_speed_ = value;
  // @@protoc_insertion_point(field_set:MitionPoint.m_speed)
}

// -------------------------------------------------------------------

// OriginPoint

// required float x = 1;
inline bool OriginPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OriginPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OriginPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OriginPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float OriginPoint::x() const {
  // @@protoc_insertion_point(field_get:OriginPoint.x)
  return x_;
}
inline void OriginPoint::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:OriginPoint.x)
}

// required float y = 2;
inline bool OriginPoint::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OriginPoint::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OriginPoint::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OriginPoint::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float OriginPoint::y() const {
  // @@protoc_insertion_point(field_get:OriginPoint.y)
  return y_;
}
inline void OriginPoint::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:OriginPoint.y)
}

// required float z = 3;
inline bool OriginPoint::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OriginPoint::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OriginPoint::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OriginPoint::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float OriginPoint::z() const {
  // @@protoc_insertion_point(field_get:OriginPoint.z)
  return z_;
}
inline void OriginPoint::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:OriginPoint.z)
}

// -------------------------------------------------------------------

// MapList

// repeated string mapname = 1;
inline int MapList::mapname_size() const {
  return mapname_.size();
}
inline void MapList::clear_mapname() {
  mapname_.Clear();
}
inline const ::std::string& MapList::mapname(int index) const {
  // @@protoc_insertion_point(field_get:MapList.mapname)
  return mapname_.Get(index);
}
inline ::std::string* MapList::mutable_mapname(int index) {
  // @@protoc_insertion_point(field_mutable:MapList.mapname)
  return mapname_.Mutable(index);
}
inline void MapList::set_mapname(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MapList.mapname)
  mapname_.Mutable(index)->assign(value);
}
inline void MapList::set_mapname(int index, const char* value) {
  mapname_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MapList.mapname)
}
inline void MapList::set_mapname(int index, const char* value, size_t size) {
  mapname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MapList.mapname)
}
inline ::std::string* MapList::add_mapname() {
  // @@protoc_insertion_point(field_add_mutable:MapList.mapname)
  return mapname_.Add();
}
inline void MapList::add_mapname(const ::std::string& value) {
  mapname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MapList.mapname)
}
inline void MapList::add_mapname(const char* value) {
  mapname_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MapList.mapname)
}
inline void MapList::add_mapname(const char* value, size_t size) {
  mapname_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MapList.mapname)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MapList::mapname() const {
  // @@protoc_insertion_point(field_list:MapList.mapname)
  return mapname_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MapList::mutable_mapname() {
  // @@protoc_insertion_point(field_mutable_list:MapList.mapname)
  return &mapname_;
}

// -------------------------------------------------------------------

// RobotRequest

// required bytes token = 1;
inline bool RobotRequest::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotRequest::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotRequest::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& RobotRequest::token() const {
  // @@protoc_insertion_point(field_get:RobotRequest.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotRequest::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RobotRequest.token)
}
inline void RobotRequest::set_token(const char* value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RobotRequest.token)
}
inline void RobotRequest::set_token(const void* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RobotRequest.token)
}
inline ::std::string* RobotRequest::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:RobotRequest.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RobotRequest::release_token() {
  // @@protoc_insertion_point(field_release:RobotRequest.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotRequest::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.token)
}

// required int32 wants = 2;
inline bool RobotRequest::has_wants() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotRequest::set_has_wants() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotRequest::clear_has_wants() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotRequest::clear_wants() {
  wants_ = 0;
  clear_has_wants();
}
inline ::google::protobuf::int32 RobotRequest::wants() const {
  // @@protoc_insertion_point(field_get:RobotRequest.wants)
  return wants_;
}
inline void RobotRequest::set_wants(::google::protobuf::int32 value) {
  set_has_wants();
  wants_ = value;
  // @@protoc_insertion_point(field_set:RobotRequest.wants)
}

// required int32 action = 3;
inline bool RobotRequest::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotRequest::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotRequest::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotRequest::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 RobotRequest::action() const {
  // @@protoc_insertion_point(field_get:RobotRequest.action)
  return action_;
}
inline void RobotRequest::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:RobotRequest.action)
}

// optional .RobotDrive drive = 4;
inline bool RobotRequest::has_drive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotRequest::set_has_drive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotRequest::clear_has_drive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotRequest::clear_drive() {
  if (drive_ != NULL) drive_->::RobotDrive::Clear();
  clear_has_drive();
}
inline const ::RobotDrive& RobotRequest::drive() const {
  // @@protoc_insertion_point(field_get:RobotRequest.drive)
  return drive_ != NULL ? *drive_ : *default_instance_->drive_;
}
inline ::RobotDrive* RobotRequest::mutable_drive() {
  set_has_drive();
  if (drive_ == NULL) {
    drive_ = new ::RobotDrive;
  }
  // @@protoc_insertion_point(field_mutable:RobotRequest.drive)
  return drive_;
}
inline ::RobotDrive* RobotRequest::release_drive() {
  // @@protoc_insertion_point(field_release:RobotRequest.drive)
  clear_has_drive();
  ::RobotDrive* temp = drive_;
  drive_ = NULL;
  return temp;
}
inline void RobotRequest::set_allocated_drive(::RobotDrive* drive) {
  delete drive_;
  drive_ = drive;
  if (drive) {
    set_has_drive();
  } else {
    clear_has_drive();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.drive)
}

// repeated .MitionPoint point = 5;
inline int RobotRequest::point_size() const {
  return point_.size();
}
inline void RobotRequest::clear_point() {
  point_.Clear();
}
inline const ::MitionPoint& RobotRequest::point(int index) const {
  // @@protoc_insertion_point(field_get:RobotRequest.point)
  return point_.Get(index);
}
inline ::MitionPoint* RobotRequest::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:RobotRequest.point)
  return point_.Mutable(index);
}
inline ::MitionPoint* RobotRequest::add_point() {
  // @@protoc_insertion_point(field_add:RobotRequest.point)
  return point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::MitionPoint >*
RobotRequest::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:RobotRequest.point)
  return &point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::MitionPoint >&
RobotRequest::point() const {
  // @@protoc_insertion_point(field_list:RobotRequest.point)
  return point_;
}

// optional .OriginPoint origin = 6;
inline bool RobotRequest::has_origin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RobotRequest::set_has_origin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RobotRequest::clear_has_origin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RobotRequest::clear_origin() {
  if (origin_ != NULL) origin_->::OriginPoint::Clear();
  clear_has_origin();
}
inline const ::OriginPoint& RobotRequest::origin() const {
  // @@protoc_insertion_point(field_get:RobotRequest.origin)
  return origin_ != NULL ? *origin_ : *default_instance_->origin_;
}
inline ::OriginPoint* RobotRequest::mutable_origin() {
  set_has_origin();
  if (origin_ == NULL) {
    origin_ = new ::OriginPoint;
  }
  // @@protoc_insertion_point(field_mutable:RobotRequest.origin)
  return origin_;
}
inline ::OriginPoint* RobotRequest::release_origin() {
  // @@protoc_insertion_point(field_release:RobotRequest.origin)
  clear_has_origin();
  ::OriginPoint* temp = origin_;
  origin_ = NULL;
  return temp;
}
inline void RobotRequest::set_allocated_origin(::OriginPoint* origin) {
  delete origin_;
  origin_ = origin;
  if (origin) {
    set_has_origin();
  } else {
    clear_has_origin();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.origin)
}

// optional int32 confirm = 7;
inline bool RobotRequest::has_confirm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RobotRequest::set_has_confirm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RobotRequest::clear_has_confirm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RobotRequest::clear_confirm() {
  confirm_ = 0;
  clear_has_confirm();
}
inline ::google::protobuf::int32 RobotRequest::confirm() const {
  // @@protoc_insertion_point(field_get:RobotRequest.confirm)
  return confirm_;
}
inline void RobotRequest::set_confirm(::google::protobuf::int32 value) {
  set_has_confirm();
  confirm_ = value;
  // @@protoc_insertion_point(field_set:RobotRequest.confirm)
}

// optional string mapname = 8;
inline bool RobotRequest::has_mapname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RobotRequest::set_has_mapname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RobotRequest::clear_has_mapname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RobotRequest::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mapname();
}
inline const ::std::string& RobotRequest::mapname() const {
  // @@protoc_insertion_point(field_get:RobotRequest.mapname)
  return mapname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotRequest::set_mapname(const ::std::string& value) {
  set_has_mapname();
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RobotRequest.mapname)
}
inline void RobotRequest::set_mapname(const char* value) {
  set_has_mapname();
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RobotRequest.mapname)
}
inline void RobotRequest::set_mapname(const char* value, size_t size) {
  set_has_mapname();
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RobotRequest.mapname)
}
inline ::std::string* RobotRequest::mutable_mapname() {
  set_has_mapname();
  // @@protoc_insertion_point(field_mutable:RobotRequest.mapname)
  return mapname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RobotRequest::release_mapname() {
  // @@protoc_insertion_point(field_release:RobotRequest.mapname)
  clear_has_mapname();
  return mapname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotRequest::set_allocated_mapname(::std::string* mapname) {
  if (mapname != NULL) {
    set_has_mapname();
  } else {
    clear_has_mapname();
  }
  mapname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:RobotRequest.mapname)
}

// -------------------------------------------------------------------

// RobotMap

// required double origin_x = 1;
inline bool RobotMap::has_origin_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotMap::set_has_origin_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotMap::clear_has_origin_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotMap::clear_origin_x() {
  origin_x_ = 0;
  clear_has_origin_x();
}
inline double RobotMap::origin_x() const {
  // @@protoc_insertion_point(field_get:RobotMap.origin_x)
  return origin_x_;
}
inline void RobotMap::set_origin_x(double value) {
  set_has_origin_x();
  origin_x_ = value;
  // @@protoc_insertion_point(field_set:RobotMap.origin_x)
}

// required double origin_y = 2;
inline bool RobotMap::has_origin_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotMap::set_has_origin_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotMap::clear_has_origin_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotMap::clear_origin_y() {
  origin_y_ = 0;
  clear_has_origin_y();
}
inline double RobotMap::origin_y() const {
  // @@protoc_insertion_point(field_get:RobotMap.origin_y)
  return origin_y_;
}
inline void RobotMap::set_origin_y(double value) {
  set_has_origin_y();
  origin_y_ = value;
  // @@protoc_insertion_point(field_set:RobotMap.origin_y)
}

// required int32 size = 3;
inline bool RobotMap::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotMap::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotMap::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotMap::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 RobotMap::size() const {
  // @@protoc_insertion_point(field_get:RobotMap.size)
  return size_;
}
inline void RobotMap::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:RobotMap.size)
}

// required int32 grids_x = 4;
inline bool RobotMap::has_grids_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotMap::set_has_grids_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotMap::clear_has_grids_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotMap::clear_grids_x() {
  grids_x_ = 0;
  clear_has_grids_x();
}
inline ::google::protobuf::int32 RobotMap::grids_x() const {
  // @@protoc_insertion_point(field_get:RobotMap.grids_x)
  return grids_x_;
}
inline void RobotMap::set_grids_x(::google::protobuf::int32 value) {
  set_has_grids_x();
  grids_x_ = value;
  // @@protoc_insertion_point(field_set:RobotMap.grids_x)
}

// required int32 grids_y = 5;
inline bool RobotMap::has_grids_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobotMap::set_has_grids_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobotMap::clear_has_grids_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobotMap::clear_grids_y() {
  grids_y_ = 0;
  clear_has_grids_y();
}
inline ::google::protobuf::int32 RobotMap::grids_y() const {
  // @@protoc_insertion_point(field_get:RobotMap.grids_y)
  return grids_y_;
}
inline void RobotMap::set_grids_y(::google::protobuf::int32 value) {
  set_has_grids_y();
  grids_y_ = value;
  // @@protoc_insertion_point(field_set:RobotMap.grids_y)
}

// required bytes zgrids = 6;
inline bool RobotMap::has_zgrids() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RobotMap::set_has_zgrids() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RobotMap::clear_has_zgrids() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RobotMap::clear_zgrids() {
  zgrids_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_zgrids();
}
inline const ::std::string& RobotMap::zgrids() const {
  // @@protoc_insertion_point(field_get:RobotMap.zgrids)
  return zgrids_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotMap::set_zgrids(const ::std::string& value) {
  set_has_zgrids();
  zgrids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RobotMap.zgrids)
}
inline void RobotMap::set_zgrids(const char* value) {
  set_has_zgrids();
  zgrids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RobotMap.zgrids)
}
inline void RobotMap::set_zgrids(const void* value, size_t size) {
  set_has_zgrids();
  zgrids_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RobotMap.zgrids)
}
inline ::std::string* RobotMap::mutable_zgrids() {
  set_has_zgrids();
  // @@protoc_insertion_point(field_mutable:RobotMap.zgrids)
  return zgrids_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RobotMap::release_zgrids() {
  // @@protoc_insertion_point(field_release:RobotMap.zgrids)
  clear_has_zgrids();
  return zgrids_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotMap::set_allocated_zgrids(::std::string* zgrids) {
  if (zgrids != NULL) {
    set_has_zgrids();
  } else {
    clear_has_zgrids();
  }
  zgrids_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), zgrids);
  // @@protoc_insertion_point(field_set_allocated:RobotMap.zgrids)
}

// -------------------------------------------------------------------

// RobotPos

// required float offset_x = 1;
inline bool RobotPos::has_offset_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotPos::set_has_offset_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotPos::clear_has_offset_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotPos::clear_offset_x() {
  offset_x_ = 0;
  clear_has_offset_x();
}
inline float RobotPos::offset_x() const {
  // @@protoc_insertion_point(field_get:RobotPos.offset_x)
  return offset_x_;
}
inline void RobotPos::set_offset_x(float value) {
  set_has_offset_x();
  offset_x_ = value;
  // @@protoc_insertion_point(field_set:RobotPos.offset_x)
}

// required float offset_y = 2;
inline bool RobotPos::has_offset_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotPos::set_has_offset_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotPos::clear_has_offset_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotPos::clear_offset_y() {
  offset_y_ = 0;
  clear_has_offset_y();
}
inline float RobotPos::offset_y() const {
  // @@protoc_insertion_point(field_get:RobotPos.offset_y)
  return offset_y_;
}
inline void RobotPos::set_offset_y(float value) {
  set_has_offset_y();
  offset_y_ = value;
  // @@protoc_insertion_point(field_set:RobotPos.offset_y)
}

// optional float angle = 3;
inline bool RobotPos::has_angle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotPos::set_has_angle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotPos::clear_has_angle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotPos::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float RobotPos::angle() const {
  // @@protoc_insertion_point(field_get:RobotPos.angle)
  return angle_;
}
inline void RobotPos::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:RobotPos.angle)
}

// -------------------------------------------------------------------

// RobotTrail

// repeated .RobotPos trail = 1;
inline int RobotTrail::trail_size() const {
  return trail_.size();
}
inline void RobotTrail::clear_trail() {
  trail_.Clear();
}
inline const ::RobotPos& RobotTrail::trail(int index) const {
  // @@protoc_insertion_point(field_get:RobotTrail.trail)
  return trail_.Get(index);
}
inline ::RobotPos* RobotTrail::mutable_trail(int index) {
  // @@protoc_insertion_point(field_mutable:RobotTrail.trail)
  return trail_.Mutable(index);
}
inline ::RobotPos* RobotTrail::add_trail() {
  // @@protoc_insertion_point(field_add:RobotTrail.trail)
  return trail_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::RobotPos >*
RobotTrail::mutable_trail() {
  // @@protoc_insertion_point(field_mutable_list:RobotTrail.trail)
  return &trail_;
}
inline const ::google::protobuf::RepeatedPtrField< ::RobotPos >&
RobotTrail::trail() const {
  // @@protoc_insertion_point(field_list:RobotTrail.trail)
  return trail_;
}

// -------------------------------------------------------------------

// RobotInfo

// required float speed = 1;
inline bool RobotInfo::has_speed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotInfo::set_has_speed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotInfo::clear_has_speed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotInfo::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float RobotInfo::speed() const {
  // @@protoc_insertion_point(field_get:RobotInfo.speed)
  return speed_;
}
inline void RobotInfo::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:RobotInfo.speed)
}

// required float voltage = 2;
inline bool RobotInfo::has_voltage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotInfo::set_has_voltage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotInfo::clear_has_voltage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotInfo::clear_voltage() {
  voltage_ = 0;
  clear_has_voltage();
}
inline float RobotInfo::voltage() const {
  // @@protoc_insertion_point(field_get:RobotInfo.voltage)
  return voltage_;
}
inline void RobotInfo::set_voltage(float value) {
  set_has_voltage();
  voltage_ = value;
  // @@protoc_insertion_point(field_set:RobotInfo.voltage)
}

// required float cur_x = 3;
inline bool RobotInfo::has_cur_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotInfo::set_has_cur_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotInfo::clear_has_cur_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotInfo::clear_cur_x() {
  cur_x_ = 0;
  clear_has_cur_x();
}
inline float RobotInfo::cur_x() const {
  // @@protoc_insertion_point(field_get:RobotInfo.cur_x)
  return cur_x_;
}
inline void RobotInfo::set_cur_x(float value) {
  set_has_cur_x();
  cur_x_ = value;
  // @@protoc_insertion_point(field_set:RobotInfo.cur_x)
}

// required float cur_y = 4;
inline bool RobotInfo::has_cur_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotInfo::set_has_cur_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotInfo::clear_has_cur_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotInfo::clear_cur_y() {
  cur_y_ = 0;
  clear_has_cur_y();
}
inline float RobotInfo::cur_y() const {
  // @@protoc_insertion_point(field_get:RobotInfo.cur_y)
  return cur_y_;
}
inline void RobotInfo::set_cur_y(float value) {
  set_has_cur_y();
  cur_y_ = value;
  // @@protoc_insertion_point(field_set:RobotInfo.cur_y)
}

// required float cur_yaw = 5;
inline bool RobotInfo::has_cur_yaw() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobotInfo::set_has_cur_yaw() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobotInfo::clear_has_cur_yaw() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobotInfo::clear_cur_yaw() {
  cur_yaw_ = 0;
  clear_has_cur_yaw();
}
inline float RobotInfo::cur_yaw() const {
  // @@protoc_insertion_point(field_get:RobotInfo.cur_yaw)
  return cur_yaw_;
}
inline void RobotInfo::set_cur_yaw(float value) {
  set_has_cur_yaw();
  cur_yaw_ = value;
  // @@protoc_insertion_point(field_set:RobotInfo.cur_yaw)
}

// -------------------------------------------------------------------

// MitionStatus

// required int32 mition_number = 1;
inline bool MitionStatus::has_mition_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MitionStatus::set_has_mition_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MitionStatus::clear_has_mition_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MitionStatus::clear_mition_number() {
  mition_number_ = 0;
  clear_has_mition_number();
}
inline ::google::protobuf::int32 MitionStatus::mition_number() const {
  // @@protoc_insertion_point(field_get:MitionStatus.mition_number)
  return mition_number_;
}
inline void MitionStatus::set_mition_number(::google::protobuf::int32 value) {
  set_has_mition_number();
  mition_number_ = value;
  // @@protoc_insertion_point(field_set:MitionStatus.mition_number)
}

// required bool mition_finish = 2;
inline bool MitionStatus::has_mition_finish() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MitionStatus::set_has_mition_finish() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MitionStatus::clear_has_mition_finish() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MitionStatus::clear_mition_finish() {
  mition_finish_ = false;
  clear_has_mition_finish();
}
inline bool MitionStatus::mition_finish() const {
  // @@protoc_insertion_point(field_get:MitionStatus.mition_finish)
  return mition_finish_;
}
inline void MitionStatus::set_mition_finish(bool value) {
  set_has_mition_finish();
  mition_finish_ = value;
  // @@protoc_insertion_point(field_set:MitionStatus.mition_finish)
}

// -------------------------------------------------------------------

// RobotResponse

// required int32 code = 1;
inline bool RobotResponse::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotResponse::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotResponse::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotResponse::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 RobotResponse::code() const {
  // @@protoc_insertion_point(field_get:RobotResponse.code)
  return code_;
}
inline void RobotResponse::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:RobotResponse.code)
}

// optional string info = 2;
inline bool RobotResponse::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotResponse::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotResponse::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotResponse::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_info();
}
inline const ::std::string& RobotResponse::info() const {
  // @@protoc_insertion_point(field_get:RobotResponse.info)
  return info_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotResponse::set_info(const ::std::string& value) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RobotResponse.info)
}
inline void RobotResponse::set_info(const char* value) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RobotResponse.info)
}
inline void RobotResponse::set_info(const char* value, size_t size) {
  set_has_info();
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RobotResponse.info)
}
inline ::std::string* RobotResponse::mutable_info() {
  set_has_info();
  // @@protoc_insertion_point(field_mutable:RobotResponse.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RobotResponse::release_info() {
  // @@protoc_insertion_point(field_release:RobotResponse.info)
  clear_has_info();
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RobotResponse::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    set_has_info();
  } else {
    clear_has_info();
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.info)
}

// optional .RobotPos pos = 3;
inline bool RobotResponse::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotResponse::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotResponse::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotResponse::clear_pos() {
  if (pos_ != NULL) pos_->::RobotPos::Clear();
  clear_has_pos();
}
inline const ::RobotPos& RobotResponse::pos() const {
  // @@protoc_insertion_point(field_get:RobotResponse.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::RobotPos* RobotResponse::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::RobotPos;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.pos)
  return pos_;
}
inline ::RobotPos* RobotResponse::release_pos() {
  // @@protoc_insertion_point(field_release:RobotResponse.pos)
  clear_has_pos();
  ::RobotPos* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void RobotResponse::set_allocated_pos(::RobotPos* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.pos)
}

// optional .RobotMap map = 4;
inline bool RobotResponse::has_map() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotResponse::set_has_map() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotResponse::clear_has_map() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotResponse::clear_map() {
  if (map_ != NULL) map_->::RobotMap::Clear();
  clear_has_map();
}
inline const ::RobotMap& RobotResponse::map() const {
  // @@protoc_insertion_point(field_get:RobotResponse.map)
  return map_ != NULL ? *map_ : *default_instance_->map_;
}
inline ::RobotMap* RobotResponse::mutable_map() {
  set_has_map();
  if (map_ == NULL) {
    map_ = new ::RobotMap;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.map)
  return map_;
}
inline ::RobotMap* RobotResponse::release_map() {
  // @@protoc_insertion_point(field_release:RobotResponse.map)
  clear_has_map();
  ::RobotMap* temp = map_;
  map_ = NULL;
  return temp;
}
inline void RobotResponse::set_allocated_map(::RobotMap* map) {
  delete map_;
  map_ = map;
  if (map) {
    set_has_map();
  } else {
    clear_has_map();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.map)
}

// optional .RobotTrail trail = 5;
inline bool RobotResponse::has_trail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobotResponse::set_has_trail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobotResponse::clear_has_trail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobotResponse::clear_trail() {
  if (trail_ != NULL) trail_->::RobotTrail::Clear();
  clear_has_trail();
}
inline const ::RobotTrail& RobotResponse::trail() const {
  // @@protoc_insertion_point(field_get:RobotResponse.trail)
  return trail_ != NULL ? *trail_ : *default_instance_->trail_;
}
inline ::RobotTrail* RobotResponse::mutable_trail() {
  set_has_trail();
  if (trail_ == NULL) {
    trail_ = new ::RobotTrail;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.trail)
  return trail_;
}
inline ::RobotTrail* RobotResponse::release_trail() {
  // @@protoc_insertion_point(field_release:RobotResponse.trail)
  clear_has_trail();
  ::RobotTrail* temp = trail_;
  trail_ = NULL;
  return temp;
}
inline void RobotResponse::set_allocated_trail(::RobotTrail* trail) {
  delete trail_;
  trail_ = trail;
  if (trail) {
    set_has_trail();
  } else {
    clear_has_trail();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.trail)
}

// optional .MitionPoint point = 6;
inline bool RobotResponse::has_point() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RobotResponse::set_has_point() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RobotResponse::clear_has_point() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RobotResponse::clear_point() {
  if (point_ != NULL) point_->::MitionPoint::Clear();
  clear_has_point();
}
inline const ::MitionPoint& RobotResponse::point() const {
  // @@protoc_insertion_point(field_get:RobotResponse.point)
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::MitionPoint* RobotResponse::mutable_point() {
  set_has_point();
  if (point_ == NULL) {
    point_ = new ::MitionPoint;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.point)
  return point_;
}
inline ::MitionPoint* RobotResponse::release_point() {
  // @@protoc_insertion_point(field_release:RobotResponse.point)
  clear_has_point();
  ::MitionPoint* temp = point_;
  point_ = NULL;
  return temp;
}
inline void RobotResponse::set_allocated_point(::MitionPoint* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.point)
}

// optional .RobotInfo status = 7;
inline bool RobotResponse::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RobotResponse::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RobotResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RobotResponse::clear_status() {
  if (status_ != NULL) status_->::RobotInfo::Clear();
  clear_has_status();
}
inline const ::RobotInfo& RobotResponse::status() const {
  // @@protoc_insertion_point(field_get:RobotResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::RobotInfo* RobotResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    status_ = new ::RobotInfo;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.status)
  return status_;
}
inline ::RobotInfo* RobotResponse::release_status() {
  // @@protoc_insertion_point(field_release:RobotResponse.status)
  clear_has_status();
  ::RobotInfo* temp = status_;
  status_ = NULL;
  return temp;
}
inline void RobotResponse::set_allocated_status(::RobotInfo* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.status)
}

// optional .MitionStatus mition = 8;
inline bool RobotResponse::has_mition() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RobotResponse::set_has_mition() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RobotResponse::clear_has_mition() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RobotResponse::clear_mition() {
  if (mition_ != NULL) mition_->::MitionStatus::Clear();
  clear_has_mition();
}
inline const ::MitionStatus& RobotResponse::mition() const {
  // @@protoc_insertion_point(field_get:RobotResponse.mition)
  return mition_ != NULL ? *mition_ : *default_instance_->mition_;
}
inline ::MitionStatus* RobotResponse::mutable_mition() {
  set_has_mition();
  if (mition_ == NULL) {
    mition_ = new ::MitionStatus;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.mition)
  return mition_;
}
inline ::MitionStatus* RobotResponse::release_mition() {
  // @@protoc_insertion_point(field_release:RobotResponse.mition)
  clear_has_mition();
  ::MitionStatus* temp = mition_;
  mition_ = NULL;
  return temp;
}
inline void RobotResponse::set_allocated_mition(::MitionStatus* mition) {
  delete mition_;
  mition_ = mition;
  if (mition) {
    set_has_mition();
  } else {
    clear_has_mition();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.mition)
}

// optional .MapList list = 9;
inline bool RobotResponse::has_list() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RobotResponse::set_has_list() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RobotResponse::clear_has_list() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RobotResponse::clear_list() {
  if (list_ != NULL) list_->::MapList::Clear();
  clear_has_list();
}
inline const ::MapList& RobotResponse::list() const {
  // @@protoc_insertion_point(field_get:RobotResponse.list)
  return list_ != NULL ? *list_ : *default_instance_->list_;
}
inline ::MapList* RobotResponse::mutable_list() {
  set_has_list();
  if (list_ == NULL) {
    list_ = new ::MapList;
  }
  // @@protoc_insertion_point(field_mutable:RobotResponse.list)
  return list_;
}
inline ::MapList* RobotResponse::release_list() {
  // @@protoc_insertion_point(field_release:RobotResponse.list)
  clear_has_list();
  ::MapList* temp = list_;
  list_ = NULL;
  return temp;
}
inline void RobotResponse::set_allocated_list(::MapList* list) {
  delete list_;
  list_ = list;
  if (list) {
    set_has_list();
  } else {
    clear_has_list();
  }
  // @@protoc_insertion_point(field_set_allocated:RobotResponse.list)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RobotDrive_Mode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RobotDrive_Mode>() {
  return ::RobotDrive_Mode_descriptor();
}
template <> struct is_proto_enum< ::RobotRequest_Wants> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RobotRequest_Wants>() {
  return ::RobotRequest_Wants_descriptor();
}
template <> struct is_proto_enum< ::RobotRequest_Action> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RobotRequest_Action>() {
  return ::RobotRequest_Action_descriptor();
}
template <> struct is_proto_enum< ::RobotMap_Grid> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RobotMap_Grid>() {
  return ::RobotMap_Grid_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_robot_2eproto__INCLUDED
